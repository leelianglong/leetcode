### 进程创建
1. 当fork系统调用在创建新进程时，也为该进程创建了完整的用户空间。
2. copy_on_write 子进程共享父进程的地址空间，只要其中任何一个进程要进行写入，则该页面就会被复制一份
3. 虚存映射：当调用exce()系统调用开始执行一个进程时，进程的可执行映像（包括代码段，数据段，堆、栈等）必须装入到进程用户空间地址，如果该进程用到任何一个共享库，则共享库也要装入到进程的用户空间。
即Linux并不是把映像装入到物理内存，相反，可执行文件只是被映射到进程的用户空间中。
4. 虚存映射的方式：共享性的（有几个进程共享某个映射，如果一个进程对这个共享的虚存区进行写，其他进程都能够感觉到，而且会修改磁盘上的对应文件。文件的共享就可以采用这种方式；私有的：进程创建的这种映射
只是为了读文件，而不是写文件；匿名的：映射与文件没有关系。
5. 用户空间相关的系统调用：fork：创建具有新的用户空间的进程，用户空间中的所有页被标记为copy_on_write，且由父子进程共享。mmap()在进程的用户空间内创建一个新的虚存区。munmap()销毁一个完整的虚存区
或其中的一部分，如果取消的虚存区在某个虚存区的中间，则这个虚存区被划分成2个。exce()装入新的可执行文件以代替当前用户空间。exit 销毁进程的用户空间及其所有的虚存区。
6. 请页机制：进程运行时，CPU访问的是用户空间的虚拟地址，Linux仅仅把当前需要的少量页面装入到内存，需要时，再通过请页机制将特定的页面调入内存。当要访问的页不存在时，上报缺页故障。缺页故障处理分为
2种：直接杀死进程，或者进入缺页异常处理，前者是编程引起的，后者是缺页引起的。

### 内存管理
1. 关注内存层次
2. 虚拟内存实现机制：Linux对内存进行管理，有5种机制，地址映射机制，内存分配机制，缓存和刷新机制，交换机制，请页机制。他们的配合关系是，首先通过映射机制把进程从磁盘映射到虚拟地址空间，当进程执行时，
如果发现要访问的页没有在物理内存时，就发出了页请求。如果有空闲的内存可供分配，就请求分配内存（这里用到了内存的分配和回收机制）并把正在使用的页记录在页缓存中（于是就使用了缓存机制）。如果没有足够的
内存可供分配，就调用交换机制，腾出一部分内存，另外在递增映射中要通过TBL来加速物理页的寻找。交换机制中页要用到交换缓存，并且把物理页内容交换到交换文件中页要通过修改页表来映射文件地址。

### 内存的分配和回收
1. 进程最关键的特征是拥有独立的虚拟地址空间。创建并执行一个进程需要下面2步：创建可执行文件与虚拟地址空间的映射；将指令寄存器设置成可执行文件的入口，并启动运行。
2. 程序装载是什么意思？上面进程启动仅仅是把可执行文件的指令和数据加载进内存，但并没有真正的装入物理内存，只通过ELF文件头部信息建立起可执行文件与虚拟递增空间的映射关系而已。真正的加载是在缺页异常
处理过程时进行的。装载过程如下：内核根据上面建立的映射关系，找到所需的内容在可执行文件中的位置。分配一个物理内存页面，并将可执行文件内容装载到内存页中。建立该物理页面和虚拟地址空间的映射关系，也就
是说填充页表，然后把控制权交给进程。
3. 物理内存管理机制： 1、伙伴（大小相同，物理地址连续）算法，负责大块连续物理内存的分配和释放，以页框为基本单位，该机制可以避免外部碎片。 2、per-cpu页框高速缓存，内核经常请求和释放单个页框，该缓存包含预先分配的页框，满足
本地CPU发出的单一页框请求；slab缓存：负责小块物理内存的分配，并且它作为高速缓存，主要针对内核中经常分配并释放的对象。4、vmalloc机制：使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大
限度的使用高端内存。
4. vmalloc() 和 kmalloc()的区别，他们都能够用于内核空间分配，kmalloc()分配的内存位于3G-high_memory之间，该段内存是与物理内存一一对应的。而vmalloc()分配内存位于VMALLOC_START ----VMALLOC_END
之间，这段非连续的内存映射到物理内存上也可能是非连续的。我们申请内存时，内核做了大量工作，无论是使用kmalloc 还是 vmalloc,最终都调用伙伴算法，通过get_free_page()内核函数活动物理内存。

### 文件系统缓存区
1. buffer 和 cache的区别：buffer是内存空间的一部分，也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓存输入和输出的数据。buffer用于各个进程产生的临时文件缓存，
一定时间段后统一写入磁盘。简单来说就是存放要写入磁盘的数据。cache经常用在磁盘IO请求上，如果有文件频繁被访问到，系统会将文件缓存到cache区，供CPU、进程等访问。简单来说，cache中的数据就是存放磁盘
中读出来的数据。
### 设备驱动模型
1. 使用一系列抽象，提供统一的设备管理视图，包括总线，类，设备和设备驱动。 bus 是CPU和一个或多个设备之间信息交互的通道，为了方便设备模型的抽象，所有的设备都应连接到总线上。class 主要是集合具有
相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。device：抽象系统中所有的硬件设备。device_driver: 用driver来抽象硬件设备的驱动程序。关键结构是Kobject.
2. platform 平台总线驱动模型： 解决驱动代码和设备信息耦合。使用这个虚拟总线将设备信息和驱动程序进行分离。平台总线会维护2条链表，分别管理设备和驱动。当一个设备注册到总线上时，总线会根据其名字
搜索对应的驱动。当一个驱动被加载到总线上，也会主动搜索设备。
