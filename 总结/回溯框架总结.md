
回溯其实就是从一开始不断前进，直到遇到阻碍行不通或者是走到结束了，就向回走一步，在继续向下探索，如果这也不能继续探索，则继续回退，以次为开始再次向下搜索。不断重复这个过程。

回溯的过程中需要考虑的问题： 
1、路径，即已经做出的选择； 
2、选择列表，即当前可以做的选择；
3、结束条件，即无法再做选择的条件；
4、在回溯的过程中对中间结果的保存；

回溯的框架代码如下：

```
result [] = {};
void backtrace(路径， 选择列表)
{
  if (满足条件) {
    把当前路径添加到结果
    return；
  }
  for(选择 in  选择列表) {
    做选择
    backtrace(路径， 选择列表)；
    撤销选择
  }
}
```
在上述模板中，只有知道所有选择列表的情况下，才可以用for循环，对于不知道的情况下，根据目前能够探索的路径，直接调用回溯（例如遍历矩阵时基于某个点有4个方向可以搜索，这里就从4个方向回溯）。

下面以全排列来说明回溯：给定一个无重复数字的数列，输出它们的全排列。
思路：
1、路径，就在已有的路径上再添加一个数字进来

2、对于N个不重复的数列，它所能够组成的排列个数是 N！，所以选择列表大小就是 N！。 再做每一次选择时，需要考虑什么样的数字可以放进来？ 题目是无重复的数字全排列，所以这里要判断每个要放进来的数字 和 当前路径上已有的数字是否重复。如果不重复，则选择它，调用backtrace() ; 撤销选择；

3、结束条件：当前路径上的数字个数是N时就满足条件了，就可以把当前路径放到结果中。

4、中间结果的存储。基于题意需要存储N个数字，作为一个合法的结果，所以在回溯函数中需要传递一个空间，用来存储每次选择的数字，还要记录选择的数字个数，所以还需一个计数值。最终返回的结果是收集每次合法的中间结果，所以再在backtrace（）函数中增加一个最终结果的存储空间和个数。

### 代码
```
bool IsRepeat(int* data, int size, int target)
{
    for (int i = 0; i < size; i++) {
        if (data[i] == target){
            return true;
        }
    }
    return false;
}

void backtrace(int* nums, int numsSize, int **result, int* returnSize, int* returnColumnSizes, int* tmpSave, int *counter)
{
    if (*counter == numsSize) {
        // 说明找到一组数据了，需要存储返回结果。
        result[*returnSize] = (int*)malloc(sizeof(int) * numsSize);
        memset(result[*returnSize], 0, sizeof(int) * numsSize);
        memcpy(result[*returnSize], tmpSave, sizeof(int) * numsSize);
        returnColumnSizes[*returnSize] = numsSize;
        (*returnSize)++;
        return;
    }
    for (int i = 0; i < numsSize; i++) {
        if (IsRepeat(tmpSave, *counter, nums[i])) { // 判断当前数字是否在既有路径中已经重复了。
            continue;
        }
        tmpSave[(*counter)++] = nums[i]; // 做选择
        backtrace(nums, numsSize, result, returnSize, returnColumnSizes, tmpSave, counter);
        (*counter)--; // 撤销选择
    }
}
int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** res = NULL;
    int counter = 1;

    for (int i = 2; i <= numsSize; i++) {
        counter = (counter * i); // n个数全排列 n!个结果
    }
    res = (int**)malloc(sizeof(int*) * counter);
    int* tmpSave = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = 0;
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * counter);
    int tmpSaveCounter = 0;
    backtrace(nums, numsSize, res, returnSize, (*returnColumnSizes), tmpSave, &tmpSaveCounter);
    return res;
}
```
