
## 概念
回溯其实就是从一开始不断前进，直到遇到阻碍行不通或者是走到结束了，就向回走一步，在继续向下探索，如果这也不能继续探索，则继续回退，以次为开始再次向下搜索。不断重复这个过程。

回溯的过程中需要考虑的问题：

1、路径，即已经做出的选择； 

2、选择列表，即当前可以做的选择；

3、结束条件，即无法再做选择的条件；

4、在回溯的过程中对中间结果的保存；

## 框架

```
result [] = {};
void backtrace(路径， 选择列表)
{
  if (满足条件) {
    把当前路径添加到结果
    return；
  }
  for(选择 in  选择列表) {
    做选择
    backtrace(路径， 选择列表)；
    撤销选择
  }
}
```
在上述模板中，只有知道所有选择列表的情况下，才可以用for循环，对于不知道的情况下，根据目前能够探索的路径，直接调用回溯（例如遍历矩阵时基于某个点有4个方向可以搜索，这里就从4个方向回溯）。

## 例题

### 全排列
下面以全排列来说明回溯：给定一个无重复数字的数列，输出它们的全排列。
#### 思路：
1.路径，就在已有的路径上再添加一个数字进来

2.对于N个不重复的数列，它所能够组成的排列个数是 N！，所以选择列表大小就是 N！。 再做每一次选择时，需要考虑什么样的数字可以放进来？ 题目是无重复的数字全排列，所以这里要判断每个要放进来的数字 和 当前路径上已有的数字是否重复。如果不重复，则选择它，调用backtrace() ; 撤销选择；

3.结束条件：当前路径上的数字个数是N时就满足条件了，就可以把当前路径放到结果中。

4.中间结果的存储。基于题意需要存储N个数字，作为一个合法的结果，所以在回溯函数中需要传递一个空间，用来存储每次选择的数字，还要记录选择的数字个数，所以还需一个计数值。最终返回的结果是收集每次合法的中间结果，所以再在backtrace（）函数中增加一个最终结果的存储空间和个数。

#### 代码
```
bool IsRepeat(int* data, int size, int target)
{
    for (int i = 0; i < size; i++) {
        if (data[i] == target){
            return true;
        }
    }
    return false;
}

void backtrace(int* nums, int numsSize, int **result, int* returnSize, int* returnColumnSizes, int* tmpSave, int *counter)
{
    if (*counter == numsSize) {
        // 说明找到一组数据了，需要存储返回结果。
        result[*returnSize] = (int*)malloc(sizeof(int) * numsSize);
        memset(result[*returnSize], 0, sizeof(int) * numsSize);
        memcpy(result[*returnSize], tmpSave, sizeof(int) * numsSize);
        returnColumnSizes[*returnSize] = numsSize;
        (*returnSize)++;
        return;
    }
    for (int i = 0; i < numsSize; i++) { // 选择列表空间
        if (IsRepeat(tmpSave, *counter, nums[i])) { // 判断当前数字是否在既有路径中已经重复了。
            continue;
        }
        tmpSave[(*counter)++] = nums[i]; // 做选择
        backtrace(nums, numsSize, result, returnSize, returnColumnSizes, tmpSave, counter);
        (*counter)--; // 撤销选择
    }
}
int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** res = NULL;
    int counter = 1;

    for (int i = 2; i <= numsSize; i++) {
        counter = (counter * i); // n个数全排列 n!个结果
    }
    res = (int**)malloc(sizeof(int*) * counter);
    int* tmpSave = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = 0;
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * counter);
    int tmpSaveCounter = 0;
    backtrace(nums, numsSize, res, returnSize, (*returnColumnSizes), tmpSave, &tmpSaveCounter);
    return res;
}
```
#### 备注
1.上述代码注意， 去重可以设置一个全局数组visit, 只有没有访问过的，才能加入结果集。另外，临时存储空间的count，可以直接设置成int，无需指针型。
```
    for (int i = 0; i < length; i++) {
        if (visit[i]) {
            continue;
        }
        visit[i] = true;
        tmpSave[count] = nums[i];
        count++;
        backtrace(res, returnSize, returnColumnSizes, visit, nums, tmpSave, count, i + 1);
        visit[i] = false;
        count--;
    }
```
2. 当前题目是排列，排列和组合的一个区别是，是否在意数字的先后顺序。 排列是要求顺序的，{1，2} 和 {2，1} 是2个排列，但是组合{1，2} 和{2，1}是1个组合。对于组合的去重，则可以在for循环的时候起始值设置成idx，而不要从0开始。leetcode 77 就是组合问题，代码如下：
```
#define COUNT 10000
void backtrace(int** res, int** returnColumnSizes, int* returnSize, int n, int k, int* tmpSave, int count, int idx)
{
    if (count == k) {
        res[*returnSize] = (int*)malloc(sizeof(int) * k);
        memset(res[*returnSize], 0, sizeof(int) * k);
        memcpy(res[*returnSize], tmpSave, sizeof(int) * k);
        (*returnColumnSizes)[*returnSize] = k;
        (*returnSize)++;
        return;
    }
    for (int i = idx; i < n; i++) { // 注意组合的去重，每次递归时，从idx开始找，
        tmpSave[count] = i + 1;
        count++;
        backtrace(res, returnColumnSizes, returnSize, n, k, tmpSave, count, i + 1); // 这里的下一次搜索要使用 i + 1
        count--;
    }
}
int** combine(int n, int k, int* returnSize, int** returnColumnSizes){
    int** res = (int**)malloc(sizeof(int*) * COUNT);
    *returnSize = 0;
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * COUNT);
    memset((*returnColumnSizes), 0, sizeof(int) * COUNT);
    int* tmpSave = (int*)malloc(sizeof(int) * (k + 1));
    memset(tmpSave, 0, sizeof(int) * (k + 1));
    backtrace(res, returnColumnSizes, returnSize, n, k, tmpSave, 0, 0);
    return res;
}
```


### 括号生成器 leetcode 22

#### 思路：
本题给定一个正整数N，请输出N对合法的括号。说明括号只有( 和 ). 如何判断括号合法？ 必须保证左右括号成对出现。（（（）））   （）（）（）合法
））（（））不合法，通过这里的特征可以看处，合法的括号：左括号数目 和 右括号数目一定相等，并且从左向右遍历括号表达式的时候，任何时刻左括号数目都大于等于右括号。按照回溯的框架来分析：

1.路径，每次只能放（ 或者 ）

2.选择列表数目。 对于本题不能显示的计算出来，但是每次回溯的路径只有2个，要么放左括号，要么放右括号。所以这里遍历这2种情况

3.结束条件，结束分异常结束和正常结束。异常结束就是 左括号数 或者 右括号数小于0 （初始化成N）或者 左括号的数目小于右括号数目。正常结束条件就是左括号数目 和 右括号数目都等于0.

4.在满足结束条件时，存储当前路径上的结果。

#### 代码
```
char** result = NULL;
void step(int left, int right, char* res, int* top, int* returnSize, int n)
{
    if (left < 0 || right < 0 || left > right) {
        return; // 异常情况要结束
    }
    if (left == 0 && right == 0) { // 找到完整的括号要结束
        result[(*returnSize)] = (char*)malloc(sizeof(char) * (2 * n + 1));
        memset(result[(*returnSize)], 0, sizeof(char) * (2 * n + 1));
        strncpy(result[(*returnSize)], res, *top);
        (*returnSize)++;
        return; 
    }
    res[(*top)++] = '('; // 把左括号放进去
    step(left - 1, right, res, top, returnSize, n);
    (*top)--; //递归完了要返回上一层，这里把上一层取消

    res[(*top)++] = ')';
    step(left, right - 1, res, top, returnSize, n);
    (*top)--;
}


char ** generateParenthesis(int n, int* returnSize){
    result = (char**)malloc(sizeof(char*) * 20000);
    char* res = (char*)malloc(sizeof(char) * (2 * n + 1));
    int top = 0;
    *returnSize = 0;
    step(n, n, res, &top, returnSize, n);

    return result;
}

```

### leetcode 39
组合总和，给定一个不重复的数列和目标值，请输出和等于目标值的所有组合，组合中的数字可以重复， 但不能出现重复组合（例如 [2,3,2] 和 [3,2,2]被认为是同一个组合）。
同样采用回溯法，有一点需要注意，见代码注释。

### 代码

```
int calcuSum(int* data, int counter)
{
    int sum = 0;
    for (int i = 0; i < counter; i++) {
        sum += data[i];
    }
    return sum;
}

void backtrace(int* candidates, int candidatesSize, int pos, int target, int curSum, int* tmpSaveAns, int* tmpCounter, int**res, int* returnSize, int* returnColumnSizes) 
{
    if (curSum > target) {
        return; // 异常退出。
    }
    if (curSum == target) {
        res[(*returnSize)] = (int*)malloc(sizeof(int) * (*tmpCounter));
        memset(res[*returnSize], 0, sizeof(int) * (*tmpCounter));
        returnColumnSizes[*returnSize] = *tmpCounter;
        memcpy(res[*returnSize], tmpSaveAns, sizeof(int) * (*tmpCounter));
        (*returnSize)++;
        return;
    }
    for (; pos < candidatesSize; pos++) {
        tmpSaveAns[(*tmpCounter)++] = candidates[pos];
        curSum = calcuSum(tmpSaveAns, (*tmpCounter));
        backtrace(candidates, candidatesSize, pos, target, curSum, tmpSaveAns, tmpCounter, res, returnSize, returnColumnSizes);
        (*tmpCounter)--;
    }
}

int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    int** result = NULL;
    result = (int**)malloc(sizeof(int*) * 10000);
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * 10000);
    int* tmpSaveAns = (int*)malloc(sizeof(int) * 10000);
    int tmpCounter = 0;
    *returnSize = 0;
    backtrace(candidates, candidatesSize, 0, target, 0, tmpSaveAns, &tmpCounter, result, returnSize, (*returnColumnSizes));
    return result;
}
```

### leetcode 93  复原IP地址
1. 总体按照IP的4段式，逐个拼接
2. 在每段中，注意从每次1位，2位，3位 这样拼接
3. 退出的条件， 已经拼接了4段； 当前的检查的起始位置已经大于等于整个字符串的长度了

### 代码
```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

char** result;
int findCounter;
bool IsValidIpSegment(const char* ip) 
{
    if (strlen(ip) > 3) {
        return false;
    } else if (ip[0] == '0') {
        return (strcmp("0", ip) == 0);
    } else {
        int a = atoi(ip);
        if (a > 255) {
            return false;
        }
    }
    return true;
}

char* subString(char* s, int start)
{
    char* res = (char*)malloc(sizeof(char) * strlen(s));
    memset(res, 0, sizeof(char) * strlen(s));
    strcpy(res, &s[start]);
    return res;
}

void MakeValidIpAddress(char* s, int part, int start, char* tmp, int* curLength)
{
    int length = strlen(s);
    if (start >= length) {
        printf("length over");
        return;
    }
    if (part == 3) {
        char* partIp = subString(s, start);
        if (IsValidIpSegment(partIp)) {
            memcpy(tmp + (*curLength), partIp, strlen(partIp));
            result[findCounter] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1)); // 注意外面是分配的二维指针，这里要使用result[xx] 来分配内存，而不能是(*result)[xx] 来分配内存。 这个有别于返回每项的个数的那种分配方式。
            memset(result[findCounter], 0, sizeof(char) * (strlen(tmp) + 1));
            memcpy(result[findCounter], tmp, strlen(tmp));
            findCounter++;
        }
        return ;
    }
    for (int i = 1; i <= 3 && start + i < length; i++) { // 这里i从1开始的原因是，我们每次要拷贝i位作为IP的一段来检查。如果是0的话就不对了。
        char* partIpBefore = (char*)malloc(sizeof(char) * 5);
        memset(partIpBefore, 0, sizeof(char) * 5);
        memcpy(partIpBefore, &s[start], i);
        if (IsValidIpSegment(partIpBefore)) {
            int cmbLength = sprintf(tmp + (*curLength), "%s.", partIpBefore);
            (*curLength) += cmbLength; // 记录当前已经在缓存中存储的位置
            MakeValidIpAddress(s, part + 1, (start + i), tmp, curLength);
            *curLength -= cmbLength; // 回溯到上次存储的地方。
        }
    }
    return;
}

char ** restoreIpAddresses(char * s, int* returnSize){
    result = (char**)malloc(sizeof(char*) * 10000); // 这里的意思是，要分配10000个存储char* 类型的空间。这里具体大小根据实际情况待定。
    *returnSize = 0;
    findCounter = 0;
    if (s == NULL) {
        return result;
    }
    char* tmp = (char*)malloc(sizeof(char) * 17);
    memset(tmp, 0, sizeof(char) * 17);
    int curLength = 0;
    MakeValidIpAddress(s, 0, 0, tmp, &curLength);
    *returnSize = findCounter;
    return result;
}
```

## 回溯题目集合
https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/

### 题目 leetcode_78
1. 当前题目是标准的回溯题目。
2. 本题关键地方是对startIndex的使用，每次调用时对startIndex进行修改，这样就没有不符合条件的路径了
3. 注意这里的int* curPos的使用，在回溯题目中要使用指针形式，方便回溯时，去掉选择。
4. 注意对一些变量++使用时，放的地方。
5. 对于一个数字的全排列个数，包含空集的情况下是 2^n 
6. 对于下面的curPos 不用定义成指针也行，直接定义成int。
7. 当前题目不需要终止条件，每次遍历直接获取即可。如果非要加终止条件的话，一定要加在收集完结果的后面， 使用if (startIndex >= numsSize) 作为退出条件。

### 代码
```
void backtrace(int* nums, int numsSize, int* tmp, int* curPos, int** res, int* returnSize, int** returnColumnSizes, int startIndex)
{
    res[*returnSize] = (int*)malloc(sizeof(int) * (*curPos));
    memset(res[*returnSize], 0, sizeof(int) * (*curPos));
    memcpy(res[*returnSize], tmp, (sizeof(int) * (*curPos)));
    (*returnColumnSizes)[*returnSize] = (*curPos);
    (*returnSize)++;

    for (int i = startIndex; i < numsSize; i++) {
        tmp[(*curPos)] = nums[i];
        (*curPos)++;
        backtrace(nums, numsSize, tmp, curPos, res, returnSize, returnColumnSizes, i + 1);
        (*curPos)--;
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    
    int count = pow(2, numsSize);
    int** result = (int**)malloc(sizeof(int*) * count);
    *returnColumnSizes = (int*)malloc(sizeof(int) * count);
    memset((*returnColumnSizes), 0, sizeof(int) * count);
    *returnSize = 0;
    int* tmp = (int*)malloc(sizeof(int) * numsSize);
    memset(tmp, 0, sizeof(int) * numsSize);
    int curPos = 0;
    int startIndex = 0;
    backtrace(nums, numsSize, tmp, &curPos, result, returnSize, returnColumnSizes,startIndex);
    return result;
}
```

### 题目 leetcode 17
1. 思路，这里做回溯时，暂存中增加的序号是每次回溯遍历到的序号，不是要添加的字符串的符合。如下代码所示，save[index] 应该是index 而不是 循环变量 i。
#### 代码
```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
const struct {
    char digit;
    char* str;
} relation [] = {
    {'2', "abc"},
    {'3', "def"},
    {'4', "ghi"},
    {'5', "jkl"},
    {'6', "mno"},
    {'7', "pqrs"},
    {'8', "tuv"},
    {'9', "wxyz"}
};

void backTrace(char** res, int* returnSize, char* save, int index, char* digits)
{
    if (index == strlen(digits)) {
        res[*returnSize] = (char*)malloc(sizeof(char) * (strlen(digits) + 1));
        memset(res[*returnSize], 0, sizeof(char) * (strlen(digits) + 1));
        strcpy(res[*returnSize], save);
        (*returnSize)++;
    } else {
        char tmp[5] = {0};
        int pos;
        for (pos = 0; pos < sizeof(relation) / sizeof(relation[0]); pos++) {
            if (relation[pos].digit == digits[index]) {
                strcpy(tmp, relation[pos].str);
                break;
            }
        }

        for (int i = 0; i < strlen(tmp); i++) {
            save[index] = relation[pos].str[i]; // 这里实际上就是获取一个数字对应的字符串，遍历这个字符串中的每个字符和下一个数字对应的字符串中的字符组合起来。
            backTrace(res, returnSize, save, index + 1, digits);
            save[index] = '\0';
        }
    }
}

char ** letterCombinations(char * digits, int* returnSize){
    const int CONT = 1000;
    *returnSize = 0;
    if (strlen(digits) == 0) {
        return digits;
    }
    char** res = (char**)malloc(sizeof(char*) * CONT);
    char* save = (char*)malloc(sizeof(char) * 5);
    memset(save, 0, sizeof(char) * 5);
    backTrace(res, returnSize, save, 0, digits);
    return res;
}
```
### leetcode 79 单词搜索
#### 思路
1. 注意当前题目要求，只要找到一个就行。所以要在dfs的4个方向找的时候，只要找到和给定字符串完全匹配的就退出。 我第一次就写成下面这样
```
for (int i,,,,) {
  ret = dfs(xxxx);
}
return ret;
```
这里就是错误了，假如在路径上先找到了一个，由于for没有退出，还在继续找，但是最后没有找到，那就吧先找到的结果覆盖了。
2.对于这种搜索，我们其实没有必要先匹配到字符串首个字符，可以直接在dfs 中搜索整个字符串里的符号即可。
3.在4个方向上的for循环里面，不要去设置访问标记，在外来一进来就设置访问标记。
4. 对于访问到单词的第几个字符的标示符，idx, 不要使用全局变量，直接使用局部参数，由于函数调用关系，就能自动做到回溯，先加，执行完回溯后再减
5. 建议把提前终止条件都放在4个方向的for循环外面去做，for循环里面只要判断更改后的边界，以及重复访问的判断，还有对idx加1.这里要在函数参数那里加1，不要在dfs 外面自增后传入参数，尤其是这个idx被设置成全局变量的时候。
6. 查看多次提交的差别，深刻理解。
```
int colum;
int row;
int direct[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
int wordLength;

bool dfs(char** board, int x, int y, int* vis, char* word, int idx)
{
    int ret = false;
    if (board[x][y] != word[idx]) {
        return false;
    } else if (idx == wordLength - 1) {
        return true;
    }
    vis[x * colum + y] = 1;
    for (int i = 0; i < 4; i++) {
        int xx = x + direct[i][0];
        int yy = y + direct[i][1];
        if (xx >= row || yy >= colum || xx < 0 || yy < 0) {
            continue;
        }
        if (vis[xx * colum + yy] == 1) {
            continue;
        }
        if(dfs(board, xx, yy, vis, word, idx + 1)) {
            ret = true;
            break;
        }
    }
    vis[x * colum + y] = 0;
    return ret;
}

bool exist(char** board, int boardSize, int* boardColSize, char * word){
    row = boardSize;
    colum = *boardColSize;
    wordLength = strlen(word);

    bool ret = false;
    int* vis = (int*)malloc(sizeof(int) * (row * colum));
    memset(vis, 0, sizeof(int) * (row * colum));
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < colum; j++) {
            ret = dfs(board, i, j, vis, word, 0);
            if (ret) {
                return ret;
            }
        }
    }
    return ret;
}

```

### leetcode 842
1. 对于毫无办法的题目，只能暴力枚举每一种可能，要想到使用dfs。
2. 对于斐波那契数列，满足的条件是， f(n) = f(n-1) + f(n-2) n >= 3.
3. 套用回溯模板。考虑异常的分支。对于本题，只有一组正确答案，所以遇到异常情况后，就可以直接退出，而不像其他的题目可以continue。
4. 考虑到相加的情况，2种int的数据相加和，可能超过了int，要使用Long来保存。
5. 注意返回的结果是int，所以如果使用long来存储可能的结果的话，那么最后要转换成int

#### 代码
```
#define RET_COUNT 10000
int gLength;

bool dfs(char* charBuf, long* numBuf, int* returnSize, int start)
{
    if (start == gLength && (*returnSize) >= 3) {
        return true;
    }
    long sum = 0;
    for (int i = start; i < gLength; i++) {
        sum = sum * 10 + charBuf[i] - '0';
        if (sum > INT_MAX) {
            break;
        }
        if (*returnSize >= 2 && sum > numBuf[*returnSize - 1] + numBuf[*returnSize - 2]) { // 这里的sum>大于是关键点，不能是！= 
            break;
        }
        if (*returnSize <= 1 || sum == numBuf[*returnSize - 1] + numBuf[*returnSize - 2]) {
            numBuf[(*returnSize)++] = sum;
            if (dfs(charBuf, numBuf, returnSize, i + 1)) {
                return true;
            }
            (*returnSize)--; // 要记得回溯这里使用指针形式，这里要减减。
        }
        if (charBuf[i] == '0' && i == start) {
            break;
        }
    }
    return false;
}

int* splitIntoFibonacci(char * S, int* returnSize){
    long* res = (long*)malloc(sizeof(long) * RET_COUNT);
    memset(res, 0, sizeof(long) * RET_COUNT);
    gLength = strlen(S);
    *returnSize = 0;
    bool result = dfs(S, res, returnSize, 0);
    *returnSize = result ? *returnSize : 0;
    int* resultBuf = (int*)malloc(sizeof(int) * *returnSize);
    for (int i = 0; i < *returnSize; i++) {
        resultBuf[i] = res[i];
    }
    return resultBuf;
}
```

### leetcode 494
#### 思路
1. 这里把target设置成 (S + sum) / 2, 需要考虑一下。其余就是回溯的常规操作.
假设加法得到的值target， 那么减法得到的值就是 sum - target.
我们要求的数值是 S = target - （sum - target） = 2target - sum. 所以
target = （S + sum） / 2;
#### 代码

```
int target;
int res;

int cmp(const void* a, const void* b)
{
    int* aa = (int*)a;
    int* bb = (int*)b;
    return aa[0] - bb[0];
}

void backTrace(int* nums, int numsSize, int tmpTarget, int idx)
{
    if (target == tmpTarget) {
        res++;
        return;
    }
    for (int i = idx; i < numsSize; i++) {
        if (tmpTarget + nums[i] > target) {
            continue;
        }
        tmpTarget += nums[i];
        backTrace(nums, numsSize, tmpTarget, i + 1);
        tmpTarget -= nums[i];
    }
}

int findTargetSumWays(int* nums, int numsSize, int S){
    int sum = 0;
    for (int i = 0; i < numsSize; i++) {
        sum += nums[i];
    }
    if (S > sum) {
        return 0;
    }
    if ((S + sum) & 1) {
        return 0;
    }
    qsort(nums, numsSize, sizeof(nums[0]), cmp);
    target = (S + sum) / 2; // 这里把 target设置成 (S + sum) / 2 。
    res = 0;
    backTrace(nums, numsSize, 0, 0);
    return res;
}
```
