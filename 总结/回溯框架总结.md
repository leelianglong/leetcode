
回溯其实就是从一开始不断前进，直到遇到阻碍行不通或者是走到结束了，就向回走一步，在继续向下探索，如果这也不能继续探索，则继续回退，以次为开始再次向下搜索。不断重复这个过程。

回溯的过程中需要考虑的问题： 
1、路径，即已经做出的选择； 
2、选择列表，即当前可以做的选择；
3、结束条件，即无法再做选择的条件；
4、在回溯的过程中对中间结果的保存；

回溯的框架代码如下：

```
result [] = {};
void backtrace(路径， 选择列表)
{
  if (满足条件) {
    把当前路径添加到结果
    return；
  }
  for(选择 in  选择列表) {
    做选择
    backtrace(路径， 选择列表)；
    撤销选择
  }
}
```
在上述模板中，只有知道所有选择列表的情况下，才可以用for循环，对于不知道的情况下，根据目前能够探索的路径，直接调用回溯（例如遍历矩阵时基于某个点有4个方向可以搜索，这里就从4个方向回溯）。

下面以全排列来说明回溯：给定一个无重复数字的数列，输出它们的全排列。
思路：
1、路径，就在已有的路径上再添加一个数字进来

2、对于N个不重复的数列，它所能够组成的排列个数是 N！，所以选择列表大小就是 N！。 再做每一次选择时，需要考虑什么样的数字可以放进来？ 题目是无重复的数字全排列，所以这里要判断每个要放进来的数字 和 当前路径上已有的数字是否重复。如果不重复，则选择它，调用backtrace() ; 撤销选择；

3、结束条件：当前路径上的数字个数是N时就满足条件了，就可以把当前路径放到结果中。

4、中间结果的存储。基于题意需要存储N个数字，作为一个合法的结果，所以在回溯函数中需要传递一个空间，用来存储每次选择的数字，还要记录选择的数字个数，所以还需一个计数值。最终返回的结果是收集每次合法的中间结果，所以再在backtrace（）函数中增加一个最终结果的存储空间和个数。

### 代码
```
bool IsRepeat(int* data, int size, int target)
{
    for (int i = 0; i < size; i++) {
        if (data[i] == target){
            return true;
        }
    }
    return false;
}

void backtrace(int* nums, int numsSize, int **result, int* returnSize, int* returnColumnSizes, int* tmpSave, int *counter)
{
    if (*counter == numsSize) {
        // 说明找到一组数据了，需要存储返回结果。
        result[*returnSize] = (int*)malloc(sizeof(int) * numsSize);
        memset(result[*returnSize], 0, sizeof(int) * numsSize);
        memcpy(result[*returnSize], tmpSave, sizeof(int) * numsSize);
        returnColumnSizes[*returnSize] = numsSize;
        (*returnSize)++;
        return;
    }
    for (int i = 0; i < numsSize; i++) { // 选择列表空间
        if (IsRepeat(tmpSave, *counter, nums[i])) { // 判断当前数字是否在既有路径中已经重复了。
            continue;
        }
        tmpSave[(*counter)++] = nums[i]; // 做选择
        backtrace(nums, numsSize, result, returnSize, returnColumnSizes, tmpSave, counter);
        (*counter)--; // 撤销选择
    }
}
int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** res = NULL;
    int counter = 1;

    for (int i = 2; i <= numsSize; i++) {
        counter = (counter * i); // n个数全排列 n!个结果
    }
    res = (int**)malloc(sizeof(int*) * counter);
    int* tmpSave = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = 0;
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * counter);
    int tmpSaveCounter = 0;
    backtrace(nums, numsSize, res, returnSize, (*returnColumnSizes), tmpSave, &tmpSaveCounter);
    return res;
}
```

### 括号生成器 leetcode 22

思路：本题给定一个正整数N，请输出N对合法的括号。说明括号只有( 和 ). 如何判断括号合法？ 必须保证左右括号成对出现。（（（）））   （）（）（）合法
））（（））不合法，通过这里的特征可以看处，合法的括号：左括号数目 和 右括号数目一定相等，并且从左向右遍历括号表达式的时候，任何时刻左括号数目都大于等于右括号。按照回溯的框架来分析：
1、路径，每次只能放（ 或者 ）

2、选择列表数目。 对于本题不能显示的计算出来，但是每次回溯的路径只有2个，要么放左括号，要么放右括号。所以这里遍历这2种情况

3、结束条件，结束分异常结束和正常结束。异常结束就是 左括号数 或者 右括号数小于0 （初始化成N）或者 左括号的数目小于右括号数目。正常结束条件就是左括号数目 和 右括号数目都等于0.

4、在满足结束条件时，存储当前路径上的结果。

### 代码
```
char** result = NULL;
void step(int left, int right, char* res, int* top, int* returnSize, int n)
{
    if (left < 0 || right < 0 || left > right) {
        return; // 异常情况要结束
    }
    if (left == 0 && right == 0) { // 找到完整的括号要结束
        result[(*returnSize)] = (char*)malloc(sizeof(char) * (2 * n + 1));
        memset(result[(*returnSize)], 0, sizeof(char) * (2 * n + 1));
        strncpy(result[(*returnSize)], res, *top);
        (*returnSize)++;
        return; 
    }
    res[(*top)++] = '('; // 把左括号放进去
    step(left - 1, right, res, top, returnSize, n);
    (*top)--; //递归完了要返回上一层，这里把上一层取消

    res[(*top)++] = ')';
    step(left, right - 1, res, top, returnSize, n);
    (*top)--;
}


char ** generateParenthesis(int n, int* returnSize){
    result = (char**)malloc(sizeof(char*) * 20000);
    char* res = (char*)malloc(sizeof(char) * (2 * n + 1));
    int top = 0;
    *returnSize = 0;
    step(n, n, res, &top, returnSize, n);

    return result;
}

```

