
回溯其实就是从一开始不断前进，直到遇到阻碍行不通或者是走到结束了，就向回走一步，在继续向下探索，如果这也不能继续探索，则继续回退，以次为开始再次向下搜索。不断重复这个过程。

回溯的过程中需要考虑的问题： 
1、路径，即已经做出的选择； 
2、选择列表，即当前可以做的选择；
3、结束条件，即无法再做选择的条件；
4、在回溯的过程中对中间结果的保存；

回溯的框架代码如下：

```
result [] = {};
void backtrace(路径， 选择列表)
{
  if (满足条件) {
    把当前路径添加到结果
    return；
  }
  for(选择 in  选择列表) {
    做选择
    backtrace(路径， 选择列表)；
    撤销选择
  }
}
```
在上述模板中，只有知道所有选择列表的情况下，才可以用for循环，对于不知道的情况下，根据目前能够探索的路径，直接调用回溯（例如遍历矩阵时基于某个点有4个方向可以搜索，这里就从4个方向回溯）。

下面以全排列来说明回溯：给定一个无重复数字的数列，输出它们的全排列。
思路：
1、路径，就在已有的路径上再添加一个数字进来

2、对于N个不重复的数列，它所能够组成的排列个数是 N！，所以选择列表大小就是 N！。 再做每一次选择时，需要考虑什么样的数字可以放进来？ 题目是无重复的数字全排列，所以这里要判断每个要放进来的数字 和 当前路径上已有的数字是否重复。如果不重复，则选择它，调用backtrace() ; 撤销选择；

3、结束条件：当前路径上的数字个数是N时就满足条件了，就可以把当前路径放到结果中。

4、中间结果的存储。基于题意需要存储N个数字，作为一个合法的结果，所以在回溯函数中需要传递一个空间，用来存储每次选择的数字，还要记录选择的数字个数，所以还需一个计数值。最终返回的结果是收集每次合法的中间结果，所以再在backtrace（）函数中增加一个最终结果的存储空间和个数。

### 代码
```
bool IsRepeat(int* data, int size, int target)
{
    for (int i = 0; i < size; i++) {
        if (data[i] == target){
            return true;
        }
    }
    return false;
}

void backtrace(int* nums, int numsSize, int **result, int* returnSize, int* returnColumnSizes, int* tmpSave, int *counter)
{
    if (*counter == numsSize) {
        // 说明找到一组数据了，需要存储返回结果。
        result[*returnSize] = (int*)malloc(sizeof(int) * numsSize);
        memset(result[*returnSize], 0, sizeof(int) * numsSize);
        memcpy(result[*returnSize], tmpSave, sizeof(int) * numsSize);
        returnColumnSizes[*returnSize] = numsSize;
        (*returnSize)++;
        return;
    }
    for (int i = 0; i < numsSize; i++) { // 选择列表空间
        if (IsRepeat(tmpSave, *counter, nums[i])) { // 判断当前数字是否在既有路径中已经重复了。
            continue;
        }
        tmpSave[(*counter)++] = nums[i]; // 做选择
        backtrace(nums, numsSize, result, returnSize, returnColumnSizes, tmpSave, counter);
        (*counter)--; // 撤销选择
    }
}
int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** res = NULL;
    int counter = 1;

    for (int i = 2; i <= numsSize; i++) {
        counter = (counter * i); // n个数全排列 n!个结果
    }
    res = (int**)malloc(sizeof(int*) * counter);
    int* tmpSave = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = 0;
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * counter);
    int tmpSaveCounter = 0;
    backtrace(nums, numsSize, res, returnSize, (*returnColumnSizes), tmpSave, &tmpSaveCounter);
    return res;
}
```

### 括号生成器 leetcode 22

思路：本题给定一个正整数N，请输出N对合法的括号。说明括号只有( 和 ). 如何判断括号合法？ 必须保证左右括号成对出现。（（（）））   （）（）（）合法
））（（））不合法，通过这里的特征可以看处，合法的括号：左括号数目 和 右括号数目一定相等，并且从左向右遍历括号表达式的时候，任何时刻左括号数目都大于等于右括号。按照回溯的框架来分析：
1、路径，每次只能放（ 或者 ）

2、选择列表数目。 对于本题不能显示的计算出来，但是每次回溯的路径只有2个，要么放左括号，要么放右括号。所以这里遍历这2种情况

3、结束条件，结束分异常结束和正常结束。异常结束就是 左括号数 或者 右括号数小于0 （初始化成N）或者 左括号的数目小于右括号数目。正常结束条件就是左括号数目 和 右括号数目都等于0.

4、在满足结束条件时，存储当前路径上的结果。

### 代码
```
char** result = NULL;
void step(int left, int right, char* res, int* top, int* returnSize, int n)
{
    if (left < 0 || right < 0 || left > right) {
        return; // 异常情况要结束
    }
    if (left == 0 && right == 0) { // 找到完整的括号要结束
        result[(*returnSize)] = (char*)malloc(sizeof(char) * (2 * n + 1));
        memset(result[(*returnSize)], 0, sizeof(char) * (2 * n + 1));
        strncpy(result[(*returnSize)], res, *top);
        (*returnSize)++;
        return; 
    }
    res[(*top)++] = '('; // 把左括号放进去
    step(left - 1, right, res, top, returnSize, n);
    (*top)--; //递归完了要返回上一层，这里把上一层取消

    res[(*top)++] = ')';
    step(left, right - 1, res, top, returnSize, n);
    (*top)--;
}


char ** generateParenthesis(int n, int* returnSize){
    result = (char**)malloc(sizeof(char*) * 20000);
    char* res = (char*)malloc(sizeof(char) * (2 * n + 1));
    int top = 0;
    *returnSize = 0;
    step(n, n, res, &top, returnSize, n);

    return result;
}

```

### leetcode 39
组合总和，给定一个不重复的数列和目标值，请输出和等于目标值的所有组合，组合中的数字可以重复， 但不能出现重复组合（例如 [2,3,2] 和 [3,2,2]被认为是同一个组合）。
同样采用回溯法，有一点需要注意，见代码注释。

### 代码

```
int calcuSum(int* data, int counter)
{
    int sum = 0;
    for (int i = 0; i < counter; i++) {
        sum += data[i];
    }
    return sum;
}

void backtrace(int* candidates, int candidatesSize, int pos, int target, int curSum, int* tmpSaveAns, int* tmpCounter,       int**res, int* returnSize, int* returnColumnSizes) 
{
    if (curSum > target) {
        return; // 异常退出。
    }
    if (curSum == target) {
        res[(*returnSize)] = (int*)malloc(sizeof(int) * (*tmpCounter));
        memset(res[*returnSize], 0, sizeof(int) * (*tmpCounter));
        returnColumnSizes[*returnSize] = *tmpCounter;
        memcpy(res[*returnSize], tmpSaveAns, sizeof(int) * (*tmpCounter));
        (*returnSize)++;
        return;
    }
    for (; pos < candidatesSize; pos++) {
        tmpSaveAns[(*tmpCounter)++] = candidates[pos];
        curSum = calcuSum(tmpSaveAns, (*tmpCounter));
        backtrace(candidates, candidatesSize, pos, target, curSum, tmpSaveAns, tmpCounter, res, returnSize, returnColumnSizes);
        (*tmpCounter)--;
    }
}

int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    int** result = NULL;
    result = (int**)malloc(sizeof(int*) * 10000);
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * 10000);
    int* tmpSaveAns = (int*)malloc(sizeof(int) * 10000);
    int tmpCounter = 0;
    *returnSize = 0;
    backtrace(candidates, candidatesSize, 0, target, 0, tmpSaveAns, &tmpCounter, result, returnSize, (*returnColumnSizes));
    return result;
}
```

### leetcode 93  复原IP地址
1. 总体按照IP的4段式，逐个拼接
2. 在每段中，注意从每次1位，2位，3位 这样拼接
3. 退出的条件， 已经拼接了4段； 当前的检查的起始位置已经大于等于整个字符串的长度了

### 代码
```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

char** result;
int findCounter;
bool IsValidIpSegment(const char* ip) 
{
    if (strlen(ip) > 3) {
        return false;
    } else if (ip[0] == '0') {
        return (strcmp("0", ip) == 0);
    } else {
        int a = atoi(ip);
        if (a > 255) {
            return false;
        }
    }
    return true;
}

char* subString(char* s, int start)
{
    char* res = (char*)malloc(sizeof(char) * strlen(s));
    memset(res, 0, sizeof(char) * strlen(s));
    strcpy(res, &s[start]);
    return res;
}

void MakeValidIpAddress(char* s, int part, int start, char* tmp, int* curLength)
{
    int length = strlen(s);
    if (start >= length) {
        printf("length over");
        return;
    }
    if (part == 3) {
        char* partIp = subString(s, start);
        if (IsValidIpSegment(partIp)) {
            memcpy(tmp + (*curLength), partIp, strlen(partIp));
            result[findCounter] = (char*)malloc(sizeof(char) * (strlen(tmp) + 1));
            memset(result[findCounter], 0, sizeof(char) * (strlen(tmp) + 1));
            memcpy(result[findCounter], tmp, strlen(tmp));
            findCounter++;
        }
        return ;
    }
    for (int i = 1; i <= 3 && start + i < length; i++) { // 这里i从1开始的原因是，我们每次要拷贝i位作为IP的一段来检查。如果是0的话就不对了。
        char* partIpBefore = (char*)malloc(sizeof(char) * 5);
        memset(partIpBefore, 0, sizeof(char) * 5);
        memcpy(partIpBefore, &s[start], i);
        if (IsValidIpSegment(partIpBefore)) {
            int cmbLength = sprintf(tmp + (*curLength), "%s.", partIpBefore);
            (*curLength) += cmbLength; //记录当前已经在缓存中存储的位置
            MakeValidIpAddress(s, part + 1, (start + i), tmp, curLength);
            *curLength -= cmbLength;
        }
    }
    return;
}

char ** restoreIpAddresses(char * s, int* returnSize){
    result = (char**)malloc(sizeof(char*) * 10000);
    *returnSize = 0;
    findCounter = 0;
    if (s == NULL) {
        return result;
    }
    char* tmp = (char*)malloc(sizeof(char) * 17);
    memset(tmp, 0, sizeof(char) * 17);
    int curLength = 0;
    MakeValidIpAddress(s, 0, 0, tmp, &curLength);
    *returnSize = findCounter;
    return result;
}
```
