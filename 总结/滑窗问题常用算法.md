
专题：
https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/30-chuan-lian-suo-you-dan-ci-de-zi-chuan-by-alexer/

/**
 * 滑动窗口的一般步骤：
 * 1、使用双指针，left 和 right； 使用while(right < strlen(s)){};
 * 2、一定要设置一个window。
 * 3、把符合条件的字符先放在window中，右移right
 * 4、直到所有的target都找到为止，停止右移。
 * 5、接下来，while(满足条件) ，在这个while中移动left。顺便把window中字符逐个移除window。 注意每次增加left都需要更新一轮结果
 * 6，在移除的过程中进行必要的信息处理。当不满足条件后，right再向右移。直到遍历完所有的字符。
 */

### 题目
计算字符串中没有重复字符的最长子串

### 思路
1、设置2个变量分别表示左边访问的位置和右边访问的位置，起初都设置成0

2、首先改变右变量，从零开始，把不重复的字符先放到窗口[0,right] 中， 这里不重复的字符通过hash[256] 来存储，每遇到一个就使用hash[s[right]] = true,

来标记访问过这个变量，在遍历的过程中，先检查hash[s[right]]是否为0，如果不为0，说明遇到重复的字符了。这里要一次把不重复的字符放进来，所以要使用

while（right < n） 来做循环，而不是使用for  + if .另外，在做题过程中发现有空格等字符，所以hash使用全部字符容量（256）。

3、当遇到重复字符后，计算当前最长的不重复的字符串长度 right -left。当前窗口【0， right + 1】接下来移动左边指针，使窗口中字符重新达到不重复。还是要使用 while （left < n）

作为外层循环，把左边字符对应hash值设置成0， 表示移动左变量，缩短窗口。每移动一次，判断一下 右边界 hash[s[right + 1]] 是不是0，如果是，则开始移动

右边界，否则继续移动左边界。每移动一次修改一下不重复最长的字符串长度。


### 代码

```
int lengthOfLongestSubstring(char * s){
    int left = 0;
    int right = 0;
    bool hash[256] = {0};
    int res = 0;
    while (right < strlen(s) && hash[s[right]] == 0) {
            hash[s[right]] = true;
            right++;
    }
    res = right - left;

    while (left < strlen(s)) {
        while (right < strlen(s) && hash[s[right]] == 0) {
            hash[s[right]] = true;
            right++;
        }
        res = res > (right - left) ? res : (right - left);
        hash[s[left]] = false;
        left++;
    }
    return res;
}

/*
* 滑动窗口思路：使用window作为计数器记录窗口中的字符出现次数，然后先向有移动right，当window中出现重复字符是，开始移动left，缩小窗口。如此往复。
*/
滑窗的解答：
int lengthOfLongestSubstring(char * s){
    int left = 0;
    int right =0;
    int hashWindow[255] = {0};
    int max = 0;

    while(right < strlen(s)) {
        char c1 = s[right];
        hashWindow[c1]++;
        right++;
        while (hashWindow[c1] > 1) { // 说明有重复的字符 ,这里要使用hashwindow[c1]来判断，不能使用hashwindow[s[right]]
            char c2 = s[left];
            hashWindow[c2]--;
            left++;
        }
        max = (right - left) > max ? (right - left) : max;  // 每次移动完左边界后，都要更新结果，不能到最外面才更新结果。
    }
    return max;
}
```

// 滑窗算法的模板
```
int left = 0;
int right = 0;
int window[] = {};

while (right < s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
```


### leetcode 567
#### 思路
1. 有个知识点，字符串的排列相同，意味着他们包含的字符个数一样多。由于全是小写字符，所以可以使用map统计每个字符出现的次数
2. 通过for循环中设置2个变量的方式构造窗口的写法要掌握。这里左边出去的符号，从map中减去，右边进来的数据，在map中加上它的次数。
3. 比较2个map是否相等，如果相等则立即返回true。否则最后退出false。

#### 代码
```
bool checkInclusion(char * s1, char * s2){
    int length1 = strlen(s1);
    int length2 = strlen(s2);
    if (length1 > length2) {
        return false;
    }
    int map1[26] = {0};
    int map2[26] = {0};
    for (int i = 0; i < length1; i++) {
        map1[s1[i] - 'a']++;
    }

    for (int i = 0; i < length1; i++) {
        map2[s2[i] - 'a']++;
    }
    if (memcmp(map1, map2, sizeof(map1)) == 0) {
        return true;
    }
    for (int i = 0, j = length1; j < length2; i++, j++) {
        map2[s2[i] - 'a']--;
        map2[s2[j] - 'a']++;
        if (memcmp(map1, map2, sizeof(map1)) == 0) {
            return true;
        }
    }
    return false;
}
```

