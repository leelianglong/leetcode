单调栈：
就是栈中的元素保持单调性，要么递增，要么递减。

单调栈代码的套路包含下面几个方法：

1、构造一个栈，可以就用数组模拟；

2、对原始数据，一定要从后往前遍历；

3、入栈和出栈的操作条件是： 如果遍历的当前元素大于等于栈顶元素，并且栈不为空，则出栈；当这个条件不满足时，查看栈是否为空，如果为空，说明没有栈中没有比

当前元素大的值，那么对应要输出的值填成-1（用了表示没有找到），否则填成栈顶元素；

把当前元素入栈，为下次查询做准备；这里一定时先出栈，然后再入栈。示例代码如下：

题目：给定一个数组，返回等长数组，数组索引对应的元素是下一个比原始元素大的元素，例如 原始数组:2, 1, 2, 4, 3; 输出的数组是：4 2 4 -1 -1.

```
int* NextGreaterElement(int* data, int dataSize)
{
    int* res = (int*)malloc(sizeof(int) * dataSize);
    memset(res, 0, sizeof(int) * dataSize);
    int* stack = (int*)malloc(sizeof(int) * dataSize);
    memset(stack, 0, sizeof(int) * dataSize);

    int top = -1;
    for (int i = dataSize - 1; i >= 0; i--) { /* 从后往前遍历 */
        while(top != -1 && stack[top] <= data[i]) { /* 栈不为空，栈顶元素小于当前元素，那么该元素应该出栈 */
            --top;
        }
        res[i] = top == -1 ? -1 : stack[top]; /* 判断是否找到，输出返回值 */
        stack[++top] = data[i]; /* 入栈 */
    }
    return res;
}
```
