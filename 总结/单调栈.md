单调栈：
就是栈中的元素保持单调性，要么递增，要么递减。

单调栈代码的套路包含下面几个方法：

1、构造一个栈，可以就用数组模拟；

2、对原始数据，一定要从后往前遍历；

3、入栈和出栈的操作条件是： 如果遍历的当前元素大于等于栈顶元素，并且栈不为空，则出栈；当这个条件不满足时，查看栈是否为空，如果为空，说明没有栈中没有比当前元素大的值，那么对应要输出的值填成-1（用了表示没有找到），否则填成栈顶元素；把当前元素入栈，为下次查询做准备；这里一定时先出栈，然后再入栈。

示例代码如下：

题目：给定一个数组，返回等长数组，数组索引对应的元素是下一个比原始元素大的元素，例如 原始数组:2, 1, 2, 4, 3; 输出的数组是：4 2 4 -1 -1.

```
int* NextGreaterElement(int* data, int dataSize)
{
    int* res = (int*)malloc(sizeof(int) * dataSize);
    memset(res, 0, sizeof(int) * dataSize);
    int* stack = (int*)malloc(sizeof(int) * dataSize);
    memset(stack, 0, sizeof(int) * dataSize);

    int top = -1;
    for (int i = dataSize - 1; i >= 0; i--) { /* 从后往前遍历 */
        while(top != -1 && stack[top] <= data[i]) { /* 栈不为空，栈顶元素小于当前元素，那么该元素应该出栈 */
            --top;
        }
        res[i] = top == -1 ? -1 : stack[top]; /* 判断是否找到，输出返回值 */
        stack[++top] = data[i]; /* 入栈 */
    }
    return res;
}
```

注意： 这里可以在比较栈顶元素时，要考虑到用小于等于，不要忘记等于。

### 单调栈可以解决下一个较大元素的问题


### 题目 leetcode 1124
思路：参考博客 
https://blog.csdn.net/qyb19970829/article/details/108477765
### 代码
```
typedef struct {
    int buf[10001];
    int top;
} Stack;

Stack * Init(void)
{
    Stack* obj = (Stack*)malloc(sizeof(Stack));
    memset(obj->buf, 0, sizeof(int) * 10001);
    obj->top = -1;
    return obj;
}

void Push(Stack* obj, int data)
{
    if (obj->top >= 10000) {
        return;
    }
    obj->top++;
    obj->buf[obj->top] = data;
}

bool IsEmpty(Stack* obj)
{
    return obj->top == -1;
}

void Pop(Stack* obj, int* data)
{
    if (IsEmpty(obj)) {
        return;
    }
    int element = 0;
    *data = obj->buf[obj->top];
    obj->top--;
}

int GetTop(Stack* obj)
{
    return obj->buf[obj->top];
}

int longestWPI(int* hours, int hoursSize){
    if (hoursSize <= 0) {
        return 0;
    }
    for (int i = 0; i < hoursSize; i++) {
        if (hours[i] > 8) {
            hours[i] = 1;
        } else {
            hours[i] = -1;
        }
    }

    int* presum = (int*)malloc(sizeof(int) * (hoursSize + 1));
    memset(presum, 0, sizeof(int) * (hoursSize + 1));

    presum[0] = 0;
    for (int i = 0; i < hoursSize; i++) {
        presum[i + 1] = presum[i] + hours[i];
    }
    Stack* obj = Init();

    for (int i = 0; i <= hoursSize; i++) {
        while(IsEmpty(obj) || presum[i] < presum[GetTop(obj)]) {
            Push(obj, i);
        }
    }
    int max = 0;
    for (int i = hoursSize; i > max; i--) {
        while(!IsEmpty(obj) && presum[i] > presum[GetTop(obj)]) {
            int cur = GetTop(obj);
            int element = 0;
            Pop(obj, &element);
            max = max > i - cur ? max : i -cur;
        }
    }
    return max;
}
```
