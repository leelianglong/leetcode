### 创建链表（尾插法）和遍历。
思路： 注意创建一个dummy节点， 使head指向dummy。 在遍历的过程中使用dummy作为移动变量， 最终返回head节点。

### 代码
```
struct ListNode {
    int val;
    struct ListNode* next;
};

struct ListNode* CreateList(int* data, int size)
{
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = data[0];
    dummy->next = NULL;
    struct ListNode* head = dummy;

    for (int i = 1; i < size; i++) {
        struct ListNode* tmp = (struct ListNode*)malloc(sizeof(struct ListNode));
        tmp->val = data[i];
        tmp->next = NULL;
        dummy->next = tmp;
        dummy = tmp;
    }
    return head;
}

void Visit(struct ListNode* head)
{
    while (head) {
        printf("%d ", head->val);
        head = head->next;
    }
}
```
### 链表访问方法
#### 思路
1. 除了上面这种迭代访问，其实链表具有天然的递归属性，具有前序后后序遍历方法，详见代码
#### 前序遍历代码
```
void traverseBfore(struct ListNode* head)
{
    if (head == NULL) {
        return;
    }
    printf("%d ", head->val);
    traverseBfore(head->next);
}
```

#### 后序遍历代码
```
void traverseAfter(struct ListNode* head)
{
    if (head == NULL) {
        return;
    }
    traverseAfter(head->next);
    printf("%d ", head->val);
}
```
### 链表逆序
#### 迭代法逆序翻转
```
struct ListNode* reverse(struct ListNode* head)
{
    struct ListNode* pre = NULL;
    struct ListNode* cur = head;
    while (cur != NULL) {
        struct ListNode* nxt = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nxt;
    }
    return pre;
}
```
### 递归法链表逆序
#### 思路
1. reserse2()的意义是，输入一个节点head，将以head为起点的链表翻转，并返回"翻转完成后的链表头节点"。
2. 结合下面代码，当前就是头节点和剩余节点的逆序2部分组成。不要深入递归里面。
3. 链表结构如下： 1 --->(NULL)<----2<---3<-----4<-----5<----6
4. 下面代码中 head->next->next = head 的理解:head->next实际上指向了2.然后把2->next 赋值成head。此时就把 head 接到逆序的链表尾部。
5. 最后使head->next = NULL. 使得最终逆序的链表末尾变成NULL。完成逆序。

#### 代码
```
struct ListNode* reverse2(struct ListNode* head)
{
    if (head == NULL || head->next == NULL) {
        return head;
    }
    struct ListNode* last = reverse2(head->next);
    head->next->next = head;
    head->next = NULL;
    return last;
}
```

### 翻转链表前K个节点
#### 思路
1. 先把链表分成2部分，即前k个需要逆序的和剩余的部分
2. 前k个节点再分成2部分，head 和 剩余逆序的。对这部分翻转时，参考上面的递归实现。
3. 差别部分是，最后head->next不是赋值成NULL，而是赋值成第K+1个节点，把剩余的部分链接起来。

#### 代码
```
// 翻转链表前N个节点
struct ListNode* successor = NULL; //记录第k个节点的后续节点
struct ListNode* reverseBeforN(struct ListNode* head, int k)
{
    if (k == 1) { // base case 如果翻转前面1个元素，实际上还是它本身。
        successor = head->next;
        return head;
    }
    struct ListNode* last = reverseBeforN(head->next, k - 1);
    head->next->next = head; // 这个完成了head 和 head->next后面逆序部分的链接。
    head->next = successor; // 这里head的next部分需要接到第K+1个节点上。正如前面保存的successor。
    return last;
}

```
### leetcode 92
#### 思路
1. 翻转链表中区间（m,n）.
2. 如果m=1，相当于翻转链表中前n个。
3. 如果我们把head的索引视为1，那么我们就是从第m个元素翻转，如果把head->next看成第一个元素，那么就是从第m-1个元素开始翻转。这样不断递归，最终到达base case。

#### 代码
```
struct ListNode* combine = NULL;
struct ListNode* reverseBeforN(struct ListNode* head, int k)
{
    if (k == 1) {
        combine = head->next;
        return head;
    }
    struct ListNode* last = reverseBeforN(head->next, k - 1);
    head->next->next = head;
    head->next = combine;
    return last;
}

struct ListNode* reverseBetween(struct ListNode* head, int left, int right){
    if (left == 1) {
        return reverseBeforN(head, right);
    }
    head->next = reverseBetween(head->next, left - 1, right - 1);
    return head;
}
```
### leetcode 1171
题目要求从链表中删除总和为0的连续节点，最终返回头节点。

思路： 

1、首先想到滑动窗口。在滑窗的思路下，左边界不动，不断扩大有边界，直到出现符合要求的解，然后再把左边界右移，找到最优解。但是看了用例左边界不动的

情况下，右边界移动到最后也找不到合适的解，另外把链表结构放在窗口中也不太容易操作。所以放弃该方法；

2、 使用前缀和办法。使用一个数组presum[n + 1]，遍历链表，计算到每个节点的和，存在该数组中。然后采用下面的方法遍历所有子数组
```
for (int i = 1; i <= n; i++) {
  for (int j = 0; j < i; j++) {
    if (presum[j] - presum[i] == 0){
      // 说明 i 和 j 之间的和为0.
    }
  }
}
```
上述方法可行，但是如何遍历链表和前缀数组结合起来，不太容易理解。

3、通过暴力法，使用双指针。

使用slow 和 fast指针，一开始slow指向 head, fast 指向 slow->next;使用2层循环，外层控制 slow， 内层控制fast；fast逐个移动，并计算访问所有节点的和。

如果和为0，则删除slow到当前fast的链表，具体使用slow->next = fast->next;并且退出内层循环；
如果和不为0，则移动fast。 fast = fast->next;

在上面退出内存循环的地方设置一个标志。在外层循环中，查看该标志，如果没有置位的情况，就移动外层循环。 slow = slow->next;如果置位了，在删除连续节点的
时候已经更新了。这就是算法过程。

4.一些注意技巧
题目要求，删除完连续节点后，要求返回链表头，但是我们在遍历是从头节点开始的，所以在遍历的过程中，已经不是头节点了。所以在一开始我们申请一个dummy节点来
保存头节点。
```
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = head;
    head = dummy;
```
另外，链表的遍历，由于不知道有多少个节点，只能使用while，要注意终止条件。循环变量就使用链表节点指针，根据情况需要几个循环，就定义几个变量。

### 代码

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeZeroSumSublists(struct ListNode* head){
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = head;
    head = dummy;

    struct ListNode* cur = head; // 此时的head已经是dummy了，所以cur中的值就是0，所以下面才可以设置 sum = 0； 因为之前在dummy->next中存储的是 真正的head。所以此时的cur->next 就指向了真正的head。
    while (cur) {
        struct ListNode* tmp = cur->next; // 这里的tmp需要赋值成cur->next, 不能赋值成 dummy->next 或者 head->next,否则tmp就是个固定的值。
        int sum = 0;
        bool find = false;
        while (tmp) {
            sum += tmp->val;
            if (sum == 0) {
                cur->next = tmp->next;
                find = true;
                break;
            }
            tmp = tmp->next;
        }
        if (!find) {
            cur = cur->next;
        }
    }
    return head->next; // 这里返回 dummy->next更直观。
}
```

### leetcode 86
思路：构建2个链表，一个用来存储小于给定x的数据，一个用来存储大于等于x的数据； 然后将2个链表合并。
注意： 亚节点的使用； 创建完小 大链表后记得最后把指向next的设为NULL； 合并时注意对空指针的判断；

### 代码

```
struct ListNode* partition(struct ListNode* head, int x){
    if (head == NULL) {
        return NULL;
    }
    struct ListNode* dummy = head;
    struct ListNode* small = (struct ListNode*)malloc(sizeof(struct ListNode));
    small->next = NULL;
    small->val = INT_MAX;
    struct ListNode* tmpSmall = small; //这里使用 tmpsmall 和 tmpbig 的作用是把较大和较小的节点链接起来。 big 和 small 是用来记录首个较大或较小的节点，在后面合并时方便使用。
    struct ListNode* big = (struct ListNode*)malloc(sizeof(struct ListNode));
    big->val = INT_MAX;
    big->next = NULL;
    struct ListNode* tmpBig = big;

    while (dummy) {
        if (dummy->val < x) {
            tmpSmall->next = dummy;
            tmpSmall = tmpSmall->next;
        } else {
            tmpBig->next = dummy;
            tmpBig = tmpBig->next;
        }
        dummy = dummy->next;
    }
    tmpSmall->next = NULL;  // 这里很关键，构建完小链表和大链表后，要把它们next指向NULL。
    tmpBig->next = NULL;


    head = small->next;
    if (head == NULL) { // [1], 1 这种特殊用例要对小链表判空。
        head = big->next;
        return head;
    }
    struct ListNode* tmpMerge = head;
    while (tmpMerge->next) {
        tmpMerge = tmpMerge->next;
    }
    tmpMerge->next = big->next;
    return head;
}
```
### 题目 面试02.06 回文链表
1. 回文的意思就是说正向读和反向读都是一样的。
2. 栈有逆序的作用，对于只有遍历操作的栈，可以使用数组代替，简化操作。
3. 先把链表元素逐个压入栈
4. 从头遍历链表时，从栈中弹出元素（由于这里用数组模拟，则倒序访问数组即可）,如果发现有不一样的元素，则返回false，说明不是回文链表，最终返回true。

#### 代码1
```
bool isPalindrome(struct ListNode* head){
    struct ListNode* dummy = head;
    int count = 0;
    while (dummy) {
        count++;
        dummy = dummy->next;
    }
    int * tmp = (int*)malloc(sizeof(int) * count);
    memset(tmp, 0, sizeof(int) * count);
    dummy = head;
    int count1 = 0;
    while (dummy) {
        tmp[count1++] = dummy->val;
        dummy = dummy->next;
    }
    dummy = head;
    while (dummy) {
        if (dummy->val != tmp[--count]) {
            return false;
        }
        dummy = dummy->next;
    }
    return true;
}
```
#### 思路2
1. 链表也天然具备递归属性，前序遍历的结果就是正向逐个访问节点，后续遍历的结果就是倒序访问每个节点，递归其实也就是栈。然后使用左右双指针比较节点的值是否相等。

#### 代码2
```
struct ListNode* left;

bool traverse(struct ListNode* right)
{
    if (right == NULL) {
        return true;
    }
    bool res = traverse(right->next); // 逐步递归，然后逐层退出，退出的时候就是倒序访问数组了。
    res = res && (left->val == right->val);
    left = left->next;
    return res;
}

bool isPalindrome(struct ListNode* head){
    left = head;
    return traverse(head);
}
```

#### 思路3
1. 使用快慢双指针，当快指针走到末尾后，慢指针就到达中间位置。 由于链表长度可能是奇数或者是偶数的，链表中心位置需要进一步判断。如果最终的fast不是空，意味着链表长度是奇数，slow还需要再走一步。然后把slow到结尾的部分逆序。
2. 然后使用左右双指针，向中间逼近，比较对应节点的值。进行回文判断。
#### 代码3
```
struct ListNode* reverse(struct ListNode* head)
{
    struct ListNode* pre = NULL;
    struct ListNode* cur = head;

    while (cur != NULL) {
        struct ListNode* nxt = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nxt;
    }
    return pre;
}

bool isPalindrome(struct ListNode* head){
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    while(fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    if (fast != NULL) {
        slow = slow->next;
    }
    struct ListNode* left = head;
    struct ListNode* right = reverse(slow);
    while(right != NULL) {
        if (left->val != right->val) {
            return false;
        }
        left = left->next;
        right = right->next;
    }
    return true;
}
```

### 题目 leetcode 206
链表原地逆序需要下面4个步骤，详见代码注释。

### 代码
```
struct ListNode* reverseList(struct ListNode* head){
    struct ListNode* next = NULL;
    struct ListNode* reverse = NULL;
    while (head) {
        next = head->next; // 用于备份下一个节点
        head->next = reverse;// 把当前节点从原链表中断开
        reverse = head; // 把当前节点链接到翻转后链表的头部
        head = next; // 进入到原链表的下一个节点。
    }
    return reverse;
}
```
下面这种方法使用双指针，cur在前， pre在后，先在局部吧cur 和 pre进行交互，然后，逐步移动。
```
struct ListNode* reverseList(struct ListNode* head){
    struct ListNode* cur = NULL;
    struct ListNode* pre = head;
    while (pre) {
        struct ListNode* tmp = pre->next; 这个很关键，记录下一次要用的节点
        pre->next = cur;// 第一次进来时，把head和后面的节点端口，再进来时，就相等是pre和cur进行交互了。
        cur = pre; // 这里 是往后移动。这2句的顺序不能反。
        pre = tmp;
    }
    return cur;
}
```

### 题目  offer 18 删除指定节点
1. 对于单链表的删除，只要确定要删除的节点的前一个节点即可，即用 pre->next = cur->next,就达到删除节点的作用。通过使用双指针，实现快的指针比慢指针先走一步。当快指针走到要删除的节点时，慢指针就是该节点的前一个节点。起初考虑一下特殊情况。
### 代码
```
struct ListNode* deleteNode(struct ListNode* head, int val){
    struct ListNode* dummy = head;
    if (dummy->val == val) {
        head = dummy->next;
        return head;
    }

    if (dummy->next->val == val) {
        head->next = dummy->next->next;
        return head;
    }
    struct ListNode* slow = head;
    struct ListNode* fast = head->next;
    while (fast) {
        if (fast->val == val) {
            slow->next = fast->next;
            break;
        }
        slow = slow->next;
        fast = fast->next;
    }
    return head;
}
```
2. 递归实现。对于这种有先后顺序的结构遍历，可以通过递归来实现。具体含义见代码注释。递归很简洁。

```
struct ListNode* deleteNode(struct ListNode* head, int val){
    if (head == NULL) { 
        return head;
    }
    if (head->val == val) {
        return head->next;
    }
    head->next = deleteNode(head->next, val); // 到这里，说明头节点不是要删除的节点。deleteNode的结果就是要删除节点的下一个节点，这里把它赋给head->next，使其相链接。
    return head; // 返回头节点不变。
}
```

### 题目 leetcode 24  链表两两交换
1. 对于链表的head在遍历的过程中肯定会使用到，结果要是还返回链表的情况下，我们要申请一个亚节点，这里一定要分配内存，使其下一个节点指向最初的head。
2. 对于辅助遍历的变量定义要放对位置。
3. 下面注释采用1，2，3，4来举例。

### 代码
```
struct ListNode* swapPairs(struct ListNode* head){
    struct ListNode* result = (struct ListNode*)malloc(sizeof(struct ListNode));
    result->next = head; // 这里head 是 1.
    struct ListNode* cur;
    cur = result;   // 从虚拟节点开始遍历。
    if (head == NULL || head->next == NULL) {
        return head;
    }

    while (cur->next != NULL && cur->next->next != NULL) {
    //这2个变量定义不能放在外面，如果放在外面 head变了，会感知不到，会导致nxt和scd始终不变。
        struct ListNode* nxt = head->next;   // nxt 指向2
        struct ListNode* scd = nxt->next;   // scd 指向3
        
        cur->next = nxt; // 
        nxt->next = head;
        head->next = scd; // 执行完后链表变成了 cur -> 2 -> 1 -> 3 -> 4。 由于head没有变，还是指向这里的1. 
        
        cur = head; // 这里把cur移动到head 1这里。
        head = head->next; // 把head移动到3这里。进行下一次循环。
    }
    return result->next;
}
```

### 合并2个有序链表
1. 要构造一个遍历节点，还要有一个返回节点。返回节点要不能被改变。
2. 注意链表不一样长的情况，另外要注意退出循环要接的节点是l1或者l2，不是l1->next, l2->next;

```
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){
    struct ListNode* head;
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    head = dummy;
    while (l1 != NULL && l2 != NULL) {
        if (l1->val > l2->val) {
            head->next = l2;
            l2 = l2->next;
        } else {
            head->next = l1;
            l1 = l1->next;
        }
        head = head->next;
    }
    head->next = (l1 == NULL) ? l2 : l1;
    return dummy->next;
}
```

### leetcode 61 
#### 思路
1. 总体思路是快慢双指针。
2. 快指针先走K步，然后慢指针再同快指针同时走
3. 在快指针到最后一个有效节点时，使用临时变量记录slow. 这个将是旋转后的最后一个节点。
4. 在快指针指向NULL时，则slow节点将是旋转后的第一个节点
5. 接下来就是将收尾部分组装起来。
6. 其余就是k与链表本身长度的一些特例处理。
7. 特殊用例
```
[1]
1
[1]
99
[1,2,3]
4
[1,2,3,4,5]
2
[]
4
[1,2,3]
3
[1,2,3,4,5]
10
```
#### 代码
```
struct ListNode* rotateRight(struct ListNode* head, int k){
    struct ListNode* dummy = head;
    struct ListNode* fast = dummy;
    struct ListNode* slow = dummy;
    if (k == 0 || head == NULL) {
        return head;
    }
    int count = 0;
    while (dummy) {
        dummy=dummy->next;
        count++;
    }
    if (k == count || count == 1) {
        return head;
    }
    printf("\n count=%u", count);
    struct ListNode* end = NULL;
    struct ListNode* start;
    if (count < k) {
        k %= count; 
    }
    if (k == 0) {
        return head;
    }
    printf("\n k=%u", k);
    while (k--) {
        fast = fast->next;
    }
    while (fast) {
        if (fast->next == NULL) {
            end = slow;
        }
        fast = fast->next;
        slow = slow->next;
    }
    start = slow;
    dummy = start;
    while (dummy->next) {
        dummy = dummy->next;
    }
    dummy->next = head;
    end->next = NULL;
    return start;
}
```
