### 二叉树的深度
二叉树的深度定义为从根节点到最远叶子节点的节点个数。
一个二叉树只有一个节点，那么深度为1； 如果只有左子树，那么深度为左子树深度 + 1； 如果只有右子树，那么深度为右子树的深度 + 1；
如果左右子树都有，那么深度为左右子树深度中较大值.
leetcode 104
### 代码
```
int dfs(struct TreeNode* node)
{
    if (node == NULL) {
        return 0;
    }
    int leftDeepth = dfs(node->left) + 1;
    int rightDeepTh = dfs(node->right) + 1;
    return leftDeepth > rightDeepTh ? leftDeepth : rightDeepTh;
}
int maxDepth(struct TreeNode* root){
    return dfs(root);
}
```

### 二叉树的最小深度
最小深度定义为从根节点到最近的叶子节点所经历的所有节点个数。leetcode 111
### 代码1
```
int minDepth(struct TreeNode* root){
    if (root == NULL) {
        return 0;
    }
    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int front = 0;
    int rear = 0;
    queue[rear++] = root;
    int height = 1; // 根节点深度为 1.下面层次遍历
    while (front != rear) {
        int curSize = rear - front;
        for (int i = 0; i < curSize; i++) {
            struct TreeNode* curNode = queue[front];
            if (curNode->left == NULL && curNode->right == NULL) { // 只要找到一个叶子节点就符合要求了，退出即可
                return height;
            }
            front++;
            if (curNode->left) {
                queue[rear++] = curNode->left;
            }
            if (curNode->right) {
                queue[rear++] = curNode->right;
            }
        }
        height++;
    }
    return height;
}
```
### 代码2
```
int dfs_deepth(struct TreeNode* bt) 
{
    if (bt == NULL) {
        return 0;
    }
    if (bt->left == NULL && bt->right == NULL) { // 已经到达叶子节点
        return 1;
    }
    int leftDeepth = dfs_deepth(bt->left);
    int rightDeepth = dfs_deepth(bt->right);
    if (bt->left == NULL || bt->right == NULL) { // 在回来的过程中，遇到某个节点没有左子树或者右子树，此时已经满足要求，遇到最近的叶子节点了，返回其中一个有值的 + 1
        return leftDeepth + rightDeepth + 1;
    }
    return (leftDeepth > rightDeepth ? rightDeepth : leftDeepth) + 1; // 左右子树都有，则返回左右子树深度中较小的一个。
}
int minDepth(struct TreeNode* root){
    return dfs_deepth(root);
}
```

### 二叉树的直径 leetcode 543
### 解题思路
1、一条路径的长度，等于该条路径上所有节点数 减1； 求直径，也就是求路径最大值。 也就是求经过的节点数最大值 减1 

2、任意一条路径可以看成以某个节点为根遍历左子树和右子树拼接起来的

3、假设我们知道对于该节点的左子树向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右子树向下遍历经过最多的节点数 R 
（即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1

4、我们以某个节点为根节点的节点个数为counter,那么二叉树的直径就是 以所有节点为根节点的 节点个数 减1.

### 代码
```
int step(struct TreeNode* root, int* nodeCounter)
{
    if (root == NULL) {
        return 0;
    }
    int lChildCounter = 0;
    int rChildCounter = 0;
    if (root->left) {
        lChildCounter = step(root->left, nodeCounter);
    }
    if (root->right) {
        rChildCounter = step(root->right, nodeCounter);
    }
    *nodeCounter = *nodeCounter > lChildCounter + rChildCounter + 1 ? *nodeCounter : lChildCounter + rChildCounter + 1; // 更新以当前节点为根节点的所在路径的最大节点数目
    return (lChildCounter > rChildCounter ? lChildCounter : rChildCounter)  + 1; // 返回以当前节点为根的子树的深度。
}

int diameterOfBinaryTree(struct TreeNode* root){
    int nodeCounter = 1;
    step(root, &nodeCounter);
    return nodeCounter - 1;
}
```
### 二叉树的最大宽度
1、树的宽度定义为树的所有层中最大宽度。只关心每一层从最左边节点开始，到最右边的节点结束，总共有多少个节点，最左边和最右边之间的空节点也算

2、解题思路：

   2.1、看到树的层，要使用BFS来遍历。
   
   2.2、另外申请一个队列用来存储遍历的每个节点的位置信息 pos,这个位置信息使用如下定义，节点i的位置设置为 pos， 那么它的左子树的位置信息设置为 2 * pos, 它的右子树的位置信息 设置为 pos * 2 + 1
   
   2.3、每层结束的时，查看位置信息队列中元素的个数，如果大于2，我们就计算当前层的宽度为位置队列队尾值 - 位置队列队头值 + 1.
   
3、小技巧：

   3.1、如果每层结束了，位置队列中的元素个数1个，那么就不用计算，该层宽度为1，所以上面计算宽度时要强调宽度大于等于2
   
   3.2、由于我们的队列入队采用的是队尾指针++，所以在for循环的外面计算某一层的宽度时，队尾的值应该是 queue[队尾指针 - 1] 才对。
   
   
### 代码
```
int widthOfBinaryTree(struct TreeNode* root){
    if (root == NULL) {
        return 0;
    }
    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    memset(queue, 0, sizeof(struct TreeNode*) * 10000);
    int rear = 0;
    int front = 0;

    int* recordPos = (int*)malloc(sizeof(int) * 10000);
    memset(recordPos, 0, sizeof(int) * 10000);
    int rP = 0;
    int fP = 0;

    int max = 1;
    int left = 0;
    int right = 0;
    queue[rear++] = root;
    recordPos[rP++] = 1;
    while (front < rear) {
        int curSize = rear - front;
        for (int k = 0; k < curSize; k++) {
            struct TreeNode* curNode = queue[front++];
            int curPos = recordPos[fP++];
           // printf("pos=%d\n", curPos);
            if (curNode->left) {
                recordPos[rP++] = curPos * 2;
                queue[rear++] = curNode->left;
            }
            if (curNode->right) {
                recordPos[rP++] = curPos * 2 + 1;
                queue[rear++] = curNode->right;
            }
        }
        if (rP - fP >= 2) {
            printf("enter: (%d %d) (%d %d)\n", fP, rP, recordPos[fP], recordPos[rP]);
            max = max > recordPos[rP - 1] - recordPos[fP] + 1 ? max : recordPos[rP - 1] - recordPos[fP] + 1;
        }
    }
    return max;
}
```
