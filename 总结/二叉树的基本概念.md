### 二叉树的深度
二叉树的深度定义为从根节点到最远叶子节点的节点个数。
一个二叉树只有一个节点，那么深度为1； 如果只有左子树，那么深度为左子树深度 + 1； 如果只有右子树，那么深度为右子树的深度 + 1；
如果左右子树都有，那么深度为左右子树深度中较大值.
leetcode 104
### 代码
```
int dfs(struct TreeNode* node)
{
    if (node == NULL) {
        return 0;
    }
    int leftDeepth = dfs(node->left) + 1;
    int rightDeepTh = dfs(node->right) + 1;
    return leftDeepth > rightDeepTh ? leftDeepth : rightDeepTh;
}
int maxDepth(struct TreeNode* root){
    return dfs(root);
}
```

### 二叉树的最小深度
最小深度定义为从根节点到最近的叶子节点所经历的所有节点和。
### 代码1
```
int minDepth(struct TreeNode* root){
    if (root == NULL) {
        return 0;
    }
    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int front = 0;
    int rear = 0;
    queue[rear++] = root;
    int height = 1; // 根节点深度为 1.下面层次遍历
    while (front != rear) {
        int curSize = rear - front;
        for (int i = 0; i < curSize; i++) {
            struct TreeNode* curNode = queue[front];
            if (curNode->left == NULL && curNode->right == NULL) { // 只要找到一个叶子节点就符合要求了，退出即可
                return height;
            }
            front++;
            if (curNode->left) {
                queue[rear++] = curNode->left;
            }
            if (curNode->right) {
                queue[rear++] = curNode->right;
            }
        }
        height++;
    }
    return height;
}
```
### 代码2
```
int dfs_deepth(struct TreeNode* bt) 
{
    if (bt == NULL) {
        return 0;
    }
    if (bt->left == NULL && bt->right == NULL) { // 已经到达叶子节点
        return 1;
    }
    int leftDeepth = dfs_deepth(bt->left);
    int rightDeepth = dfs_deepth(bt->right);
    if (bt->left == NULL || bt->right == NULL) { // 在回来的过程中，遇到某个节点没有左子树或者右子树，此时已经满足要求，遇到最近的叶子节点了，返回其中一个有值的 + 1
        return leftDeepth + rightDeepth + 1;
    }
    return (leftDeepth > rightDeepth ? rightDeepth : leftDeepth) + 1; // 左右子树都有，则返回左右子树深度中较小的一个。
}
int minDepth(struct TreeNode* root){
    return dfs_deepth(root);
}
```

### 二叉树的直径 leetcode 543
### 解题思路
1、一条路径的长度，等于该条路径上所有节点数 减1； 求直径，也就是求路径最大值。 也就是求经过的节点数最大值 减1 

2、任意一条路径可以看成以某个节点为根遍历左子树和右子树拼接起来的

3、假设我们知道对于该节点的左子树向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右子树向下遍历经过最多的节点数 R 
（即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1

4、我们以某个节点为根节点的节点个数为counter,那么二叉树的直径就是 以所有节点为根节点的 节点个数 减1.

### 代码
```
int step(struct TreeNode* root, int* nodeCounter)
{
    if (root == NULL) {
        return 0;
    }
    int lChildCounter = 0;
    int rChildCounter = 0;
    if (root->left) {
        lChildCounter = step(root->left, nodeCounter);
    }
    if (root->right) {
        rChildCounter = step(root->right, nodeCounter);
    }
    *nodeCounter = *nodeCounter > lChildCounter + rChildCounter + 1 ? *nodeCounter : lChildCounter + rChildCounter + 1; // 更新以当前节点为根节点的所在路径的最大节点数目
    return (lChildCounter > rChildCounter ? lChildCounter : rChildCounter)  + 1; // 返回以当前节点为根的子树的深度。
}

int diameterOfBinaryTree(struct TreeNode* root){
    int nodeCounter = 1;
    step(root, &nodeCounter);
    return nodeCounter - 1;
}
```
