### 节点的度
二叉树某个节点的度表示，当前节点包含的子树个数。

### 二叉树所有节点数
采用DFS，思路如下： 所有节点数  =  根节点数（1） + 左子树的节点数 + 右子树的节点数
### 代码
```
int step(struct TreeNode* root)
{
    if (root == NULL) {
        return 0;
    }
    int lChildCounter = step(root->left) + 1;
    int rChildCounter = step(root->right) + 1;
    return lChildCounter + rChildCounter - 1;
}
```
### 二叉树叶子节点数
叶子节点是没有左子树也没有右子树的节点，采用DFS遍历，遍历到叶子节点时把计数加1.
### 代码
```
void step(struct TreeNode* root, int* leafCounter)
{
    if (root->left == NULL && root->right == NULL) {
        (*leafCounter)++;
        return;
    }
    if (root->left) {
        step(root->left, leafCounter);
    }
    if (root->right) {
        step(root->right, leafCounter);
    }
}

int minDepth(struct TreeNode* root){
    int counter = 0;
    step(root, &counter);
    return counter;
}
```


### 二叉树的深度
二叉树的深度定义为从根节点到最远叶子节点的节点个数。
一个二叉树只有一个节点，那么深度为1； 如果只有左子树，那么深度为左子树深度 + 1； 如果只有右子树，那么深度为右子树的深度 + 1；
如果左右子树都有，那么深度为左右子树深度中较大值.
leetcode 104
### 代码
```
int dfs(struct TreeNode* node)
{
    if (node == NULL) {
        return 0;
    }
    int leftDeepth = dfs(node->left) + 1;
    int rightDeepTh = dfs(node->right) + 1;
    return leftDeepth > rightDeepTh ? leftDeepth : rightDeepTh;
}
int maxDepth(struct TreeNode* root){
    return dfs(root);
}
```
### leetcode 226 翻转二叉树
#### 思路
1. 就是把左右节点交换，才有递归和 BFS代码.
2. 这里要翻转要直接交换， 我起初使用 root->left = traverse(root->right); root->right = traverse(root->left). 这个失败了
#### 代码
```
#define SWAP(a, b) do {\
                        struct TreeNode* tmp;\
                        tmp = a;\
                        a = b;\
                        b = tmp;\
                    } while (0)

struct TreeNode* invertTree(struct TreeNode* root){
    if (root == NULL) {
        return root;
    }
    SWAP(root->left, root->right);
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```
```
#define SWAP(a, b) do {\
                        struct TreeNode* tmp;\
                        tmp = a;\
                        a = b;\
                        b = tmp;\
                    } while (0)
#define COUNT 50000
struct TreeNode* invertTree(struct TreeNode* root){
    struct TreeNode** queue[50000] = {0};
    int front = 0;
    int rear = 0;
    if (root == NULL) {
        return root;
    }
    queue[rear++] = root;
    while (front < rear) {
        int curSize = rear - front;
        for (int i = 0; i < curSize; i++) {
            struct TreeNode* curNode = queue[front++];
            SWAP(curNode->left, curNode->right);
            if (curNode->left)
                queue[rear++] = curNode->left;
            if (curNode->right)
                queue[rear++] = curNode->right;
        }
    }
    return root;
}
```
### leetcode 617
#### 思路
1. 创建一个节点root，用来存储头结点，并且要把它的左右孩子都设置成NULL，然后根据root1 和 root2的情况，获取他们的val。
2. 创建root->left 和 root->right. 它们是 root1 和 root2的左子树 和 右子树递归调用。
3. 关键一点是在调用时需要判断一些 root1  和 root2 是否是NULL，如果是空就传NULL 否则传子树。
#### 代码
```
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){
    if (root1 == NULL && root2 == NULL) {
        return NULL;
    } 
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->left = NULL;
    root->right = NULL;

    if (root1 == NULL && root2 != NULL) {
        root->val = root2->val;
    } else if (root1 != NULL && root2 == NULL) {
        root->val = root1->val;
    } else {
        root->val = root1->val + root2->val;
    }
    root->left = mergeTrees(root1 == NULL ? NULL : root1->left, root2 == NULL ? NULL : root2->left);
    root->right = mergeTrees(root1 == NULL ? NULL : root1->right,root2 == NULL ? NULL : root2->right);
    return root;
}
```

### 二叉树的最小深度
最小深度定义为从根节点到最近的叶子节点所经历的所有节点个数。leetcode 111
### 代码1
```
int minDepth(struct TreeNode* root){
    if (root == NULL) {
        return 0;
    }
    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int front = 0;
    int rear = 0;
    queue[rear++] = root;
    int height = 1; // 根节点深度为 1.下面层次遍历
    while (front != rear) {
        int curSize = rear - front;
        for (int i = 0; i < curSize; i++) {
            struct TreeNode* curNode = queue[front];
            if (curNode->left == NULL && curNode->right == NULL) { // 只要找到一个叶子节点就符合要求了，退出即可
                return height;
            }
            front++;
            if (curNode->left) {
                queue[rear++] = curNode->left;
            }
            if (curNode->right) {
                queue[rear++] = curNode->right;
            }
        }
        height++;
    }
    return height;
}
```
### 代码2
```
int dfs_deepth(struct TreeNode* bt) 
{
    if (bt == NULL) {
        return 0;
    }
    if (bt->left == NULL && bt->right == NULL) { // 已经到达叶子节点
        return 1;
    }
    int leftDeepth = dfs_deepth(bt->left);
    int rightDeepth = dfs_deepth(bt->right);
    if (bt->left == NULL || bt->right == NULL) { // 在回来的过程中，遇到某个节点没有左子树或者右子树，此时已经满足要求，遇到最近的叶子节点了，返回其中一个有值的 + 1
        return leftDeepth + rightDeepth + 1;
    }
    return (leftDeepth > rightDeepth ? rightDeepth : leftDeepth) + 1; // 左右子树都有，则返回左右子树深度中较小的一个。
}
int minDepth(struct TreeNode* root){
    return dfs_deepth(root);
}
```

### 二叉树的三种方式遍历

#### 递归方式
1. 思路：使用递归很方便的遍历二叉树，这里需要注意的是，三种方式遍历方式，在递归上都是左子树 和 右子树在执行，获取相关元素都是在根节点上执行。下面以中序遍历说明
2. 代码模板
```
  void f(TreeNode node) {
    if (node == NULL) {
        return ;
    }
    if (node.left) {
    
    }
    
    if (node.right) {
    
    }
  }
```
3.  二叉树上每一个节点都会走3次。这一点很重要。
#####  中序遍历代码
```
int* result = NULL;
void dfs(struct TreeNode* root, int*result, int* returnSize)
{
    if (root->left) {
        dfs(root->left, result, returnSize);
    }
    result[(*returnSize)++] = root->val; // 这里获取元素一定是在根节点处获取，
    if (root->right) {
        dfs(root->right, result, returnSize);
    }
    
}
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    result = (int*)malloc(sizeof(int) * 10000);
    memset(result, 0, sizeof(int) * 10000);
    *returnSize = 0;
    if (root == NULL) {
        return result;
    }
    dfs(root, result, returnSize);
    return result;
}
```
### 迭代法
#### 前序遍历
1. 使用栈，先把根节点入栈
2. 再以栈为空，为结束条件，出栈，如果有右子树，则把右子树入栈
3. 如果有左子树，则把左子树入栈
4. 每次出栈时，获取当前节点值
5. 代码
```
#define COUNT 1000
typedef struct {
    struct TreeNode* buf[COUNT];
    int top;
} Stack;

Stack* Init(void)
{
    Stack* obj = (Stack*)malloc(sizeof(Stack));
    for (int i = 0; i < COUNT; i++) {
        obj->buf[i] = NULL;
    }
    obj->top = -1;
    return obj;
}

bool IsEmpty(Stack* obj)
{
    return obj->top == -1;
}

void Push(Stack* obj, struct TreeNode* element)
{
    obj->top++;
    obj->buf[obj->top] = element;
}

struct TreeNode* Pop(Stack* obj)
{
    if (IsEmpty(obj)) {
        return NULL;
    }
    struct TreeNode* element = obj->buf[obj->top];
    obj->top--;
    return element;
}

int* preorderTraversal(struct TreeNode* root, int* returnSize){
    *returnSize = 0; 
    int* res = (int*)malloc(sizeof(int) * COUNT);
    memset(res, 0, sizeof(int) * COUNT);
    if (root == NULL) {
        return res;
    }
    Stack* obj = Init();
    Push(obj, root);
    while (!IsEmpty(obj)) {
        struct TreeNode* element = Pop(obj);
        res[*returnSize] = element->val;
        (*returnSize)++;
        if (element->right) {
            Push(obj, element->right);
        }
        if (element->left) {
            Push(obj, element->left);
        }
    }
    return res;
}
```
#### 后序遍历
1. 使用2个栈(A,B)，其中一个栈用于遍历原有的二叉树，在弹出时，先放到另一个栈中。最后在把另一个栈中元素逐个弹出即可。栈能够逆序
3. 先把根节点放入栈A，然后弹出根节点放在B栈
5. 如果弹出的节点有左子树，则把左子树入栈A
7. 如果弹出的节点有右子树，则把右子树入栈A
9. 如果栈不为空时，A出栈，入栈B
11. 栈B逐个出栈打印

#### 中序遍历
1. 使用一个栈
3. 把树的左子树一次入栈，直到没有左子树就停下来
5. 弹出直接打印，并走到这个弹出节点的右子树上
7. 执行步骤2.

### 二叉搜索树第K大元素
1. 对于中序遍历，可以稍微变换一下访问顺序。即先右子树，根节点，左子树。这样遍历可以解决类似二叉搜索树第K大问题.少搜索一些。
2. 注意这里可以使用全局变量，如果想在递归的过程修改数值，那么改数值要么采用这种全局变量，要么使用指针形式，来修改指针指向的内存地址。
如果是局部变量的话，再递归调用过程中有问题。

```
int res;
int count;
void dfs(struct TreeNode* root)
{
    if (root == NULL || count == 0) {
        return;
    }
    if (root->right) {
        dfs(root->right);
    }
    if ((--count) == 0) {
        res = root->val;
        return;
    }
    if (root->left) {
        dfs(root->left);
    }
}
int kthLargest(struct TreeNode* root, int k){
    count = k;
    res = 0;
    dfs(root);
    return res;
}
```

### 平衡二叉树
基本概念就是任意一个节点的左子树和右子树的高度相差不超过1. 如何判断一个二叉树是平衡二叉树，需要下面三步,尤其是后面2步，如果没有的话导致错误： 
1. 计算所有节点的高度，判断其左子树和右子树的高度差 
2. 判断所有的左子树是否是平衡二叉树 
3. 判断所有的右子树是否是平衡二叉树

### 代码
```
int height(struct TreeNode* root)
{
    if (root == NULL) {
        return 0;
    }
    int leftHeight = height(root->left) + 1;
    int rightHeight = height(root->right) + 1;
    return leftHeight > rightHeight ? leftHeight : rightHeight;
}

bool isBalanced(struct TreeNode* root){
    if (root == NULL) {
        return true;
    }
    return abs((height(root->left) - height(root->right))) <= 1 && isBalanced(root->left) && isBalanced(root->right);
}
```

### 二叉搜索树
概念： 二叉搜索树的性质，它或者是一颗空树，或者是一颗具有下面特点的树，如果该树有左子树，所有左子树的节点都小于根节点的值；如果该树有右子树，右子树的值均大于根节点。

#### 二叉搜索树的最近的公共节点 leetcode 235
1. 可以从root开始逐个向下搜索，在搜索的过程中注意这是二叉搜索树，使用它的性质，如果当前节点的值比target要大，说明target在左子树，那么往左子树遍历。反之向其右子树遍历。
2. 在遍历的工程中把走过的节点依次存储下来。
3. 既然要找最近的公共父节点，那么遍历的路径肯定从头开始都是相同的，只有遇到第一个不一样节点时，就找到了最近的公共父节点。
4. 一个节点本身也是自己的父节点，所以在找到当前target时，需要把这个target也添加到路径之中。
#### 代码
```
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    const int count = 10000;
    struct TreeNode* pPath[count];
    struct TreeNode* qPath[count];
    struct TreeNode* pubParent;

    struct TreeNode* dummy = root;
    int pCount = 0;
    while (dummy) {
        pPath[pCount++] = dummy;
        if (p->val == dummy->val) { // 注意这里的比较要使用，val相等，不能使用 struct TreeNode* 相等来比较。这个值肯定不相等。
            pPath[pCount++] = dummy;
            break;
        } else if (p->val > dummy->val) {
            dummy = dummy->right;
        } else {
            dummy = dummy->left;
        }
    }
    int qCount = 0;
    dummy = root;
    while (dummy) {
        qPath[qCount++] = dummy;
        if (q->val == dummy->val) {
            qPath[qCount++] = dummy;
            break;
        } else if (q->val > dummy->val) {
            dummy = dummy->right;
        } else {
            dummy = dummy->left;
        }
    }
    int idx = qCount > pCount ? pCount : qCount;
    for (int i = 0; i < idx; i++) {
        if (pPath[i] == qPath[i]) {
            pubParent = pPath[i];
            continue;
        } else {
            break;
        }
    }
    return pubParent;
}
```
### 二叉树的最近公共祖先 leetcode 236
1. 要从底向上，搜索整树才能找到。
2. 采用后序遍历。具体过程见代码注释。

#### 代码
```
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q){
    if ( p == root || q == root || root == NULL) { 
        return root; // 这里返回root，实际上就是找到一个节点，他的左子树是p 右子树是q.那么它的最近公共祖先就是 当前节点。这里要存整体的递归上看， 不要进入到递归里面去。
    }
    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);
    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);
    if (left != NULL && right != NULL) {
        return root;
    }
    if (left != NULL && right == NULL) {
        return left;
    }
    if (left == NULL && right != NULL) {
        return right;
    }
    return NULL;
}
```

### 二叉树镜像
#### 判断二叉树是否是镜像的
二叉树是否是镜像，主要考虑以下几个方面：
1、基于递归思路，一个二叉树是镜像的，它们的左子树 和 右子树是镜像的。
2、如果左子树和右子树是镜像的，它们必须满足下面的条件，1，如果这2个树是空的；2，如果其中一个有值，另一个为空，那么二叉树不镜像；3，如果这2个树的根节点不一样，那么它们也不是镜像的。

#### 代码
```
bool isMirror(struct TreeNode* left, struct TreeNode* right)
{
    if (left == NULL && right == NULL) {
        return true;
    }

    if (left != NULL && right == NULL) {
        return false;
    }

    if (left == NULL && right != NULL) {
        return false;
    }

    if (left->val != right->val) {
        return false;
    }
    bool m1 = isMirror(left->left, right->right);
    bool m2 = isMirror(left->right, right->left);
    return m1 && m2;
}

bool isSymmetric(struct TreeNode* root){
    if (root == NULL) {
        return true;
    }
    return isMirror(root->left, root->right);
}
```
#### 把二叉树翻转成镜像输出
1、采用递归，把二叉树的左子树 和 右子树交换，逐层递进
2、最终返回最初的root即可

#### 代码
```
struct TreeNode* mirrorTree(struct TreeNode* root){
    if (root != NULL) {
        struct TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        if (root->left) {
            mirrorTree(root->left);
        }
        if (root->right) {
            mirrorTree(root->right);
        }
    }
    return root;
}
```

### 二叉树的直径 leetcode 543
#### 解题思路
1. 一条路径的长度，等于该条路径上所有节点数 减1； 求直径，也就是求路径最大值。 也就是求经过的节点数最大值 减1 
2. 任意一条路径可以看成以某个节点为根遍历左子树和右子树拼接起来的
3. 假设我们知道对于该节点的左子树向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右子树向下遍历经过最多的节点数 R 
（即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1
4. 我们以某个节点为根节点的节点个数为counter,那么二叉树的直径就是 以所有节点为根节点的 节点个数 减1 的最大值.
5. 在计算左右叶子节点个数时，lChildCounter = step(root->left, maxNodeCounter) + 1; 还是在最后 (lChildCounter > rChildCounter ? lChildCounter : rChildCounter)  + 1; 效果是一样的

### 代码
```
int step(struct TreeNode* root, int* maxNodeCounter)
{
    if (root == NULL) {
        return 0;
    }
    int lChildCounter = 0;
    int rChildCounter = 0;
    if (root->left) {
        lChildCounter = step(root->left, maxNodeCounter);
    }
    if (root->right) {
        rChildCounter = step(root->right, maxNodeCounter);
    }
    *maxNodeCounter = *maxNodeCounter > lChildCounter + rChildCounter + 1 ? *maxNodeCounter : lChildCounter + rChildCounter + 1; // 更新以当前节点为根节点的所在路径的最大节点数目.某个节点为根节点的所在路径长度是左子树的节点个数 + 右子树的节点个数 + 1
    return (lChildCounter > rChildCounter ? lChildCounter : rChildCounter)  + 1; // 返回以当前节点为根的子树的深度，也就是从根节点到最远叶子节点的个数。
}

int diameterOfBinaryTree(struct TreeNode* root){
    int nodeCounter = 1;
    step(root, &nodeCounter);
    return nodeCounter - 1;
}
```
### 二叉树的最大宽度
1、树的宽度定义为树的所有层中最大宽度。只关心每一层从最左边节点开始，到最右边的节点结束，总共有多少个节点，最左边和最右边之间的空节点也算

2、解题思路：

   2.1、看到树的层，要使用BFS来遍历。
   
   2.2、另外申请一个队列用来存储遍历的每个节点的位置信息 pos,这个位置信息使用如下定义，节点i的位置设置为 pos， 那么它的左子树的位置信息设置为 2 * pos, 它的右子树的位置信息 设置为 pos * 2 + 1
   
   2.3、每层结束的时，查看位置信息队列中元素的个数，如果大于2，我们就计算当前层的宽度为位置队列队尾值 - 位置队列队头值 + 1.
   
3、小技巧：

   3.1、如果每层结束了，位置队列中的元素个数1个，那么就不用计算，该层宽度为1，所以上面计算宽度时要强调宽度大于等于2
   
   3.2、由于我们的队列入队采用的是队尾指针++，所以在for循环的外面计算某一层的宽度时，队尾的值应该是 queue[队尾指针 - 1] 才对。
   
   
### 代码
```
int widthOfBinaryTree(struct TreeNode* root){
    if (root == NULL) {
        return 0;
    }
    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    memset(queue, 0, sizeof(struct TreeNode*) * 10000);
    int rear = 0;
    int front = 0;

    int* recordPos = (int*)malloc(sizeof(int) * 10000);
    memset(recordPos, 0, sizeof(int) * 10000);
    int rP = 0;
    int fP = 0;

    int max = 1;
    int left = 0;
    int right = 0;
    queue[rear++] = root;
    recordPos[rP++] = 1;
    while (front < rear) {
        int curSize = rear - front;
        for (int k = 0; k < curSize; k++) {
            struct TreeNode* curNode = queue[front++];
            int curPos = recordPos[fP++];
           // printf("pos=%d\n", curPos);
            if (curNode->left) {
                recordPos[rP++] = curPos * 2;
                queue[rear++] = curNode->left;
            }
            if (curNode->right) {
                recordPos[rP++] = curPos * 2 + 1;
                queue[rear++] = curNode->right;
            }
        }
        if (rP - fP >= 2) {
            printf("enter: (%d %d) (%d %d)\n", fP, rP, recordPos[fP], recordPos[rP]);
            max = max > recordPos[rP - 1] - recordPos[fP] + 1 ? max : recordPos[rP - 1] - recordPos[fP] + 1;
        }
    }
    return max;
}
```

## 二叉树的所有路径
所谓二叉树的所有路径是指从根节点到叶子节点的所有路径。
算法模板如下：
```
void dfs(struct TreeNode* root, int* buf, int counter)
{
    if(root->left==NULL && root->right == NULL) {
        buf[counter++] = root->val;
        return;
    }
    buf[counter++] = root->val;
    if (root->left) {
        dfs(root->left， buf, counter);
    }
    if (root->right) {
        dfs(root->right, buf, counter)
    }
}
```

注意：

1、这里是要记录从根节点到所有叶子节点的值，所以这个buf应该是提前分配好的空间，相当于是全局变量
     
2、要记录当前访问了第几个元素，这里使用 int counter, 而不是使用指针型的int* counter. 这里因为前者相当于是一个局部变量，每次递归调用结束后的值还是
它调用前的值，在调用的规程中并没有改变它的值，这样在我们访问完一个左叶子节点后，需要退到其父节点时，访问右叶子节点。这个counter的值就恢复成刚要进左叶子节点前的值，访问右叶子节点时，在次基础上加1就能够访问了。  
  如果使用了int*counter,那么在递归调用的过程中改变了这个值，在访问完左叶子节点，退到其父节点，准备访问右叶子节点时，这个*counter 的值还是，访问左叶子节点改变后的值。那么以它作为索引，把右叶子节点数据往里放的时候，就出错了。如果使用int* counter来记录位置的话，详见下面的模板。
     
```
void dfs(struct TreeNode* root, int* buf, int* counter)
{
    if(root->left==NULL && root->right == NULL) {
        buf[（*counter)++] = root->val;
        return;
    }
    buf[*(counter)++] = root->val;
    if (root->left) {
        dfs(root->left， buf, counter);
        (*counter)--;
    }
    if (root->right) {
        dfs(root->right, buf, counter)
        (*counter)--;
    }
}
```
总体来看，如果遍历的结果只有1条的情况下，可以使用这种int* counter型。对于遍历所有二叉树的叶子节点的，都使用局部遍历形式来记录位置，这样更方便。

### leetcode 257
思路：

1、从根节点，逐个访问到叶子节点；每访问一个节点记录一下节点值；

2、这里有点特殊的是需要使用 -> 来把所有的节点连起来，使用 sprintf()函数来把整型值转换成字符。这里使用格式"%d->",很巧妙。如果在访问节点时，就把

   -> 加到buf中，会导致 counter不好处理，导致大部分用例过不了。参考我的第一次提交。
   
3、sprinf() 函数成功返回当前格式化的字符串的长度，不包括结束符，如果失败了返回-1.失败的原因是缓存有问题。

4、注意这里在记录存储的元素个数时，使用的是局部变量，见上面段落的分析

### 代码
```
void dfs(struct TreeNode* root, char** result,int* returnSize, int* tmpSave, int tmpCounter) 
{
    if (root->left == NULL && root->right == NULL) {
        char* str = (char*)malloc(sizeof(char) * 1024);
        memset(str, 0, sizeof(char) * 1024);
        int length = 0;
        for (int k = 0; k < tmpCounter; k++) {
            length += sprintf(str + length, "%d->", tmpSave[k]);
        }
        sprintf(str + length, "%d", root->val);
        result[*returnSize] = (char*)malloc(sizeof(char) * (1024));
        memset(result[*returnSize], 0, sizeof(char) * (1024));
        strcpy(result[*returnSize], str);
        (*returnSize)++;
        return;
    }
    tmpSave[(tmpCounter)++] = root->val;
    if (root->left) {
        dfs(root->left, result, returnSize, tmpSave, tmpCounter);
    }
    if (root->right) {
        dfs(root->right, result, returnSize, tmpSave, tmpCounter);
    }
}

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    char** result = (char**)malloc(sizeof(char*) * 10000);
    *returnSize = 0;
    if (root == NULL) {
        return result;
    }
    int counter = 0;
    int* tmpSave = (int*)malloc(sizeof(int) * 100);
    memset(tmpSave, 0, sizeof(int) * 100);
    dfs(root, result, returnSize, tmpSave, counter);
    return result;
}
```
上面这个题目是二叉树所有路径搜索的基础，leetcode上有很多题，都是在遍历基础上再添加其他功能，例如：

https://leetcode-cn.com/problems/path-sum/    路径总和

https://leetcode-cn.com/problems/path-sum-ii/  路径总和 II

https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/   从叶节点开始的最小字符串


### 从叶节点开始的最小字符串
思路：
1、二叉树的所有路径遍历，获取从根节点到所有叶子节点的字符串

2、把所有的字符串逆序

3、把所有字符串按照字典序，使用qsort 排序。

### 代码
```
void reverseStr(char* data)
{
    int right = strlen(data) - 1;
    int left = 0;
    while (left <= right) {
        char tmp = data[left];
        data[left] = data[right];
        data[right] = tmp;
        left++;
        right--;
    }
}
int cmp(const void* a, const void* b)
{
    char* aa = *(char**)a;
    char* bb = *(char**)b;
    return strcmp(aa, bb);
}
void step(struct TreeNode* root, char** res, int* returnSize, int tmpCounter, char* tmpSave)
{
    if (root->left == NULL && root->right == NULL) {
        tmpSave[(tmpCounter)] = (root->val - 0) + 'a';
        (tmpCounter)++;
        res[(*returnSize)] = (char*)malloc(sizeof(char) * 8500);
        memset(res[*returnSize], 0, sizeof(char) * 8500);
        strncpy(res[*returnSize], tmpSave, (tmpCounter));
        (*returnSize)++;
        return;
    }
    tmpSave[(tmpCounter)] = (root->val - 0) + 'a';
    (tmpCounter)++;
    if (root->left) {
        step(root->left, res, returnSize, tmpCounter, tmpSave);
    }
    if (root->right) {
        step(root->right, res, returnSize, tmpCounter, tmpSave);
    }
}

char * smallestFromLeaf(struct TreeNode* root){
    if (root == NULL) {
        return NULL;
    }
    char** res = (char**)malloc(sizeof(char*) * 8500);
    int returnSize = 0;
    int tmpCounter = 0;
    char* tmpSave = (char*)malloc(sizeof(char) * 8500);
    memset(tmpSave, 0, sizeof(char) * 8500);
    step(root, res, &returnSize, tmpCounter, tmpSave);
    for (int i = 0; i < returnSize; i++) {
       // printf("\n11 %s",  res[i]);
        reverseStr(res[i]);
        //printf("\n22 %s",  res[i]);
    }
    qsort(res, returnSize, sizeof(char*),cmp);
    #if 0
    printf("\nafter sort:\n");
    for (int k = 0; k < returnSize; k++) {
        printf("%s\n", res[k]);
    }
    #endif
    return res[0];
}
```

## 二叉树的构建
### 从先序遍历还原二叉树  leetcode 1028

二叉树在构建时，一定要在创建一个节点时，要把他的左子树和右子树先设置成NULL(这个很重要，避免在最终叶子节点没有赋值成NULL，结构返回不了)，然后在后续的过程中再通过创建节点连接到其父节点的左子树或者右子树上。

### 代码
```

#define STACK_SIZE 1000
typedef struct {
    int top;
    struct TreeNode* data[STACK_SIZE];
} TreeStack;

TreeStack* InitStack()
{
    TreeStack* tmp = (TreeStack*)malloc(sizeof(TreeStack));
    tmp->top = -1;
    for (int i = 0; i < STACK_SIZE; i++) {
        tmp->data[i] = NULL;
    }
    return tmp;
}

bool PushStack(TreeStack* st, struct TreeNode* element)
{
    if (st->top > STACK_SIZE - 1) {
        return false;
    }
    st->top++;
    st->data[st->top] = element;
    return true;
}

struct TreeNode* PopStack(TreeStack* st)
{
    struct TreeNode* element = NULL;
    if (st->top == -1) {
        return element;
    }
    element = st->data[st->top];
    st->top--;
    return element;
}
struct TreeNode* GetTopElement(TreeStack* st)
{
    return st->data[st->top];
}

int findNum(char* data, int index)
{
    while (index < strlen(data) && data[index] >= '0' && data[index] <= '9') {
        index++;
    }
    return index;
}

int findDeepth(char* data, int index) {
    while (index < strlen(data) && data[index] == '-') {
        index++;
    }
    return index;
}

struct TreeNode* recoverFromPreorder(char * S){
    char tmpSaveStr[100] = {0};
    TreeStack* stack = InitStack();
    int index = findNum(S, 0);
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->left = NULL;
    root->right = NULL;
    strncpy(tmpSaveStr, &S[0], index);
    root->val = atoi(tmpSaveStr);
    printf("\n %d", root->val);
    memset(tmpSaveStr, 0, sizeof(tmpSaveStr));
    PushStack(stack, root);
#if 1
    for (; index < strlen(S); index++) {
        int r = findDeepth(S, index);
        //printf("\ntop=%d, r=%d, index=%d", stack->top, r, index);
        while (stack->top > r - index) {
            PopStack(stack);
        }
        struct TreeNode* node = GetTopElement(stack);
        int e = findNum(S, r);
        //printf("\ne=%d", e);
        strncpy(tmpSaveStr, &S[r],  e - r);
        int num = atoi(tmpSaveStr);
        //printf("\nnum=%d", num);
        memset(tmpSaveStr, 0, sizeof(tmpSaveStr));
        struct TreeNode* tmp = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        tmp->val = num;
        tmp->left = NULL;
        tmp->right = NULL;
        if (node->left) {
            node->right = tmp;
        } else {
            node->left = tmp;
        }
        PushStack(stack, tmp);
        index = e;
    }
#endif
    return root;
}
```

### 从先序和中序遍历构造二叉树 leetcode 105
思路：
1、 树的遍历一般有宽度优先 和 深度优先2种方式。对于层次遍历 需要采用宽度优先搜索， 对于前序 中序 后序遍历其实都是深度优先搜索。

2、先序遍历的意思是 先遍历 根节点 再左子树 再右子树； 中序遍历，则是先遍历左子树 根节点 右子树。所以先序遍历中首个元素是根节点， 在中序遍历中，找到根节点所在的位置 pos, 这个位置就把二叉树分成左子树 和 右子树 两部分。

3、对于中序遍历来说，位置[0， pos)  和 （pos , 结束] 就是以pos为根节点的左右子树.

4、下面代码就是把前序遍历分成左右2部分，把中序遍历分成左右2部分

5、接下来处理 前序遍历的左半部分，中序遍历的左半部分； 以及前序遍历的右半部分 和 中序遍历的右半部分。

下面以 前序 【1 2 4 5 3 6 7】 中序 【4 2 5 1 6 3 7】来举例说明

第一步： 根节点 1， 对于的pos 是 3.

第二步： 计算左子树，即处理前序遍历的左半部分 和 中序的左半部分，所以前序左半部分起始位置 preorder + 1,就从 2 开始,长度到底pos = 3， 即到5； 
中序遍历的左半部分，从inorder 开始，即从4 开始， 长度是 pos = 3；

第三步： 计算右子树，即处理前序遍历的右半部分 和 中序遍历的右半部分。preorder + 1 + pos， 即 从 3开始， 长度就是总长度减去 (1 + pos);
中序遍历的有办法 inorder + 1 + pos 即从6 开始，长度也是 总长度 减去 （1 + pos) 
这样不断递归，直到前序 或者 中序数组为空即可。

### 代码
```
struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){
    if (preorderSize <= 0) {
        return NULL; // 这里很关键呀，就是叶子节点。如果没有这句，就段错误了。
    }

    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val = preorder[0]; //前序遍历的首元素肯定是跟节点
    int index = 0;
    while (index < inorderSize && inorder[index] != preorder[0]) {
        index++; // 找到中序遍历中的跟节点所在的位置
    }
    printf("\n index=%u", index);
    root->left = buildTree(preorder + 1, index, inorder, index); // 处理前序遍历的左半部分，中序遍历的左半部分，它们的结果是左子树
    root->right = buildTree(preorder + 1 + index, preorderSize - (index + 1), inorder + index + 1, inorderSize - (index + 1)); // 处理前序遍历的右半部分 和 中序遍历的有半部分，得到的结果是 右子树。
    return root;
}
```

### 先序遍历构造二叉树 leetcode 1008
思路：
1、仅仅给定前序遍历是不能唯一确定二叉树的。本题外加一个条件构造与之相匹配的二叉搜索树。二叉搜索树的概念是左孩子的值都小于根节点，并且 右孩子的值都大于根节点。

2、基于二叉搜索树的特点，如果对其进行中序遍历那么它所有节点的值是升序排列的。所以把给定的前序排列值进行升序排列后就是该二叉树的中序遍历结果。

3、因此，基于前序和中序遍历就能唯一确定一个二叉树。

### 代码
```
struct TreeNode* buildTree(int* preorder, int preSize, int* inorder, int inSize)
{
    if (preSize <= 0) {
        return NULL;
    }
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val = preorder[0];
    root->left = NULL;
    root->right = NULL;
    int pos;
    for (pos = 0; pos < inSize; pos++) {
        if (inorder[pos] == root->val) {
            break;
        }
    }
    root->left = buildTree(preorder + 1, pos, inorder, inSize);
    root->right = buildTree(preorder + pos + 1, preSize - pos - 1, inorder + pos + 1, inSize - pos - 1);
    return root;
}

int cmp(const void* a, const void* b) {
    return *(int*)a - *(int*)b;
}

struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){
    int* inOrder = (int*)malloc(sizeof(int) * preorderSize);
    memset(inOrder, 0, sizeof(int) * preorderSize);
    memcpy(inOrder, preorder, sizeof(int) * preorderSize);
    qsort(inOrder, preorderSize, sizeof(int), cmp);
    struct TreeNode* root = buildTree(preorder, preorderSize, inOrder, preorderSize);
    return root;
}
```

### 代码2
思路：
由于要构建二叉搜索树，其有一个特性，即根节点的值大于所有左子树的各个节点的值，并小于右子树的各个节点的值。又由于给定的前序遍历中所有数字都不同，所以我可以从前序遍历的数组中依次拿出各个数字，使其和已经构建的二叉搜索树中的根节点值比较。如果比根节点的值小，就放在左子树，比根节点值大的就放在右子树。

注意点：
1、先创建根节点，要把对应的左子树 和 右子树 设置成 NULL；

2、依次处理剩余的前序遍历的数字

2.1、 要从根节点开始遍历，只要还有左/右子树就一直搜索，直到没有左、右子树。在搜索的过程中要比较当前值和根节点的大小，确定在左子树还是在右子树上继续搜索。

2.2、 在没有左子树 和 右子树时，就创建一个节点，把当前值赋给新创建的节点的根，并把其左子树 和 右子树都设置成NULL。然后判断当前根节点和这个值的大小关系，确定把这个节点接在左子树还是右子树。

### 代码
```
struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->left = NULL;
    root->right = NULL;
    root->val = preorder[0];
    struct TreeNode* dummy;
    for (int i = 1; i < preorderSize; i++) {
        dummy = root;
        while ((preorder[i] < dummy->val && dummy->left != NULL) || (preorder[i] > dummy->val && dummy->right != NULL)) {
            if (preorder[i] > dummy->val) {
                dummy = dummy->right;
            } else {
                dummy = dummy->left;
            }
        }
        struct TreeNode* e = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        e->val = preorder[i];
        e->left = NULL;
        e->right = NULL;
        if (dummy->val > preorder[i]) {
            dummy->left = e;
        } else {
            dummy->right = e;
        }
    }
    return root;
}
```
### 根据前序 和 后序遍历构造二叉树 leetcode 889
思路：
/*
* 本题是根据前序遍历和后序遍历构造匹配的二叉树。这里可以利用的知识点是 ：
1、前序遍历的第一个 和 后序遍历的最后一个是根节点。
2、除过根节点后，前序遍历的第一个节点 也就是 后序遍历的倒数第一个节点。 这样拿前序遍历的第一个节点 在后序遍历中找到相等的元素，那么后序遍历数据中从
开始到这个位置都是左子树，从这个位置的下一个位置到倒数第一个位置就是右子树。
3、这样确定前序遍历的左子树 的起始结束位置是 [prestart + 1,  prestart + length + 1], 后序遍历的左子树数的起始位结束置是 [poststart, pos]
前序遍历的右子树的起始结束位置是 [preStart + lengh + 2, preEnd] 后序遍历的起始结束位置[[pos + 1, postEnd - 1]
4、这里各个子树的起始结束位置是关键，确定后直接递归就计算出来。
*/
### 代码
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* buildTree(int* pre, int preStart, int preEnd, int* post, int postStart, int postEnd) {
    if (preStart > preEnd) {
        return NULL; // 这个是结束条件
    }
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val = pre[preStart];
    root->left = NULL;
    root->right = NULL;
    if (preStart == preEnd) {
        return root;
    }
    int val = pre[preStart + 1];
    int pos;
    for (pos = postStart; pos <= postEnd; pos++) {
        if (val == post[pos]) {
            int length = pos - postStart;
            root->left = buildTree(pre, preStart + 1, preStart + length + 1, post, postStart, pos);
            root->right = buildTree(pre, preStart + length + 2, preEnd, post, pos + 1, postEnd - 1);
        }
    }
    return root;
}

struct TreeNode* constructFromPrePost(int* pre, int preSize, int* post, int postSize){
    int preStart = 0;
    int preEnd = preSize - 1;
    int postStart = 0;
    int postEnd = postSize - 1;
    return buildTree(pre, preStart, preEnd, post, postStart, postEnd);
}
```

### 从中序和后序遍历构造二叉树 leetcode 106
思路：
1、后序遍历最后一个元素是根节点，使用该元素在中序遍历中把二叉树树分成左子树和右子树。
2、接下来通过中序遍历和后序遍历分别构造左子树和右子树，递归实现。
3、结束条件是无论是中序遍历还是后序遍历的序列长度小于0。
注意：每次遍历的起始位置 和 遍历长度

### 代码
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){
    if (inorderSize <= 0) {
        return NULL;
    }
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val = postorder[postorderSize - 1];
    root->left = NULL;
    root->right = NULL;
    int pos = 0;
    for (int i = 0; i < inorderSize; i++) {
        if (inorder[i] == root->val) {
            pos = i;
            break;
        }
    }
    root->left = buildTree(inorder, pos, postorder, pos);
    root->right = buildTree(inorder + pos + 1, inorderSize - pos - 1, postorder + pos, postorderSize - 1 - pos);
    return root;
}
```

### leetcode 114
#### 思路
1. 题目的意思是把二叉树展开成链表
2. 具体做法分2不，先找到以当前root为根的左右子树，然后把左子树接到右子树的位置上。然后把找到当前左子树的最右节点，将前面的右子树挂上。
注意遍历到左子树的末尾时，记得使用NULL。
3. 当前题目最初不知道要做什么，下面代码来着题解
#### 代码
```
void flatten(struct TreeNode* root){
    if (root == NULL) {
        return;
    }
    flatten(root->left);
    flatten(root->right);
    struct TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = NULL;
    while (root->right != NULL) {
        root = root->right;
    }
    root->right = tmp;
}
```
