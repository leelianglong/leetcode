### 图的二维数组表示方法

图的邻接矩阵(adjacency matrix)存储方式是用2个数组来表示图，一个一维数组存储图中的顶点信息，一个二维数组（邻接矩阵），存储图的边的信息。

设图G有n个顶点，则邻接矩阵是一个n * n的方阵

arc[i][j] = 1 表示 顶点 i 和 j 之间有连线

arc[i][j] = 0 表示 顶点 i 和 j 之间没有连线

使用一个一维数组表示顶点信息：
vertex[n] = {v1,v2,v3,....vn};

对于无向图的邻接矩阵是一个对称矩阵。主对角线上都是0.

![无向图表示](https://github.com/leelianglong/leetcode/blob/master/%E6%80%BB%E7%BB%93/graph_icon/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89.PNG)

示例代码如下：
```
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>

typedef char vertexType; // 顶点类型
typedef int edgeType;
#define MAX_VERTEX    100

// 顶点(n)和边数关系 n * (n - 1) / 2
typedef struct {
    vertexType vex[MAX_VERTEX]; // 顶点
    edgeType arc[MAX_VERTEX][MAX_VERTEX]; // 邻接矩阵
    int nodesNum;
    int edgeNum;
} UGraph;


void CreateUndirecGraph(UGraph* g)
{
    printf("\r\n输入顶点和边数\r\n");
    scanf("%d %d", &g->nodesNum, &g->edgeNum);

    int i;
    for (i = 0; i < g->nodesNum; i++) {
        scanf("%d", &g->vex[i]);
    }

    int j;
    for (i = 0; i < g->nodesNum; i++) {
        for (j = 0; j < g->nodesNum; j++) {
            g->arc[i][j] = 0; // 邻接矩阵的初始化
        }
    }

    int k;
    int w;
    i = 0;
    j = 0; 
    printf("\nedge=%d\n", g->edgeNum);
    for (k = 0; k < g->edgeNum; k++) {
        printf("输入边(vi,vj)上的下标i, 下标j和权重w\n");
        scanf("%d %d %d", &i, &j, &w);
        g->arc[i][j] = w;
        g->arc[j][i] = g->arc[i][j];
    }
}

void PrintNode(UGraph* g)
{
    int i;
    for (i = 0; i < g->nodesNum; i++) {
        printf("%d", g->vex[i]);
    }
}

void PrintEdge(UGraph* g)
{
    int i;
    int j;

    for (i = 0; i < g->nodesNum; i++) {
        for (j = 0; j < g->nodesNum; j++) {
            printf("%2d", g->arc[i][j]);
        }
        printf("\n");
    }
}

void main(void)
{
    UGraph g;

    CreateUndirecGraph(&g);
    PrintNode(&g);
    PrintEdge(&g);
}
```

图的遍历：从图的某一个顶点出发访问遍历图中其余顶点，且使每一个顶点仅仅被访问一次。避免对一个节点多次访问，设置一个visited[]数组，访问过的设置为1，没有访问的设置成0. 图的遍历一般采用DFS和BFS来执行。
用来遍历的图如下所示：
![无向图]()
