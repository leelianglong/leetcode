### 题目 2个数都使用逆序存储在2个链表中， 把相加的结果也逆序存储。

本题：
1、要注意对于链表，创建了节点，一定要给注意对数值 和 下一个节点赋值，如果忘记对下一个节点赋值的话，会导致段错误。

2、使用亚节点来遍历链表。



思路1： 把2个数，看成具体的数值，使用long long 的结构存储，代码如下：但是对于超大数，则会溢出

```

struct ListNode {
    int val;
    struct ListNode *next;
};

#define STACK_LENGTH 1000
typedef struct {
    int data[STACK_LENGTH];
    int top;
} Stack;

Stack* CreateStack(void)
{
    Stack* obj = (Stack*)malloc(sizeof(Stack));
    if (obj == NULL) {
        return obj;
    }
    for (int i = 0; i < STACK_LENGTH; i++) {
        obj->data[i] = 0;
    }
    obj->top = -1;
    return obj;
}

bool PushStack(Stack* obj, int data)
{
    if (obj == NULL) {
        return false;
    }
    obj->top++;
    obj->data[obj->top] = data;
    return true;
}

int PopStack(Stack* obj)
{
    int data = INT_MIN;
    if (obj == NULL) {
        return data;
    }
    data = obj->data[obj->top];
    obj->top--;
    return data;
}

bool IsStackEmpty(Stack* obj)
{
    return obj->top == -1;
}

void reverse(char* data, int length)
{
    int left = 0;
    int right = length - 1;
    while (left <= right) {
        char tmp = data[left];
        data[left] = data[right];
        data[right] = tmp;
        left++;
        right--;
    }
}

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    Stack* obj1 = CreateStack();
    Stack* obj2 = CreateStack();

    while (l1 != NULL) {
        PushStack(obj1, l1->val);
        l1 = l1->next;
    }

    while (l2 != NULL) {
        PushStack(obj2, l2->val);
        l2 = l2->next;
    }

    long long num1 = 0;
    while (!IsStackEmpty(obj1)) {
        int obj1Pop = PopStack(obj1);
        num1 = num1 * 10 + obj1Pop;
    }

    long long num2 = 0;
    while (!IsStackEmpty(obj2)) {
        int obj2Pop = PopStack(obj2);
        num2 = num2 * 10 + obj2Pop;
    }


    long long sum = num1 + num2;
    char tmpArray[20] = {0};
    sprintf(tmpArray, "%lld", sum);
    reverse(tmpArray, strlen(tmpArray));


    struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->next = NULL;
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->next = NULL;
    head = dummy;
    dummy->val = tmpArray[0] - 0x30;
    for (int i = 1; i < strlen(tmpArray); i++) {
        dummy->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        dummy->next->val = tmpArray[i] - 0x30;
        dummy->next->next = NULL;
        dummy = dummy->next;
    }
    return head;
}
```

思路2： 直接相加注意进位，不使用数据结构表示，但是进位没有处理好，

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#define STACK_LENGTH 1000
typedef struct {
    int data[STACK_LENGTH];
    int top;
} Stack;

Stack* CreateStack(void)
{
    Stack* obj = (Stack*)malloc(sizeof(Stack));
    if (obj == NULL) {
        return obj;
    }
    for (int i = 0; i < STACK_LENGTH; i++) {
        obj->data[i] = 0;
    }
    obj->top = -1;
    return obj;
}

bool PushStack(Stack* obj, int data)
{
    if (obj == NULL) {
        return false;
    }
    obj->top++;
    obj->data[obj->top] = data;
    return true;
}

int PopStack(Stack* obj)
{
    int data = INT_MIN;
    if (obj == NULL) {
        return data;
    }
    data = obj->data[obj->top];
    obj->top--;
    return data;
}

bool IsStackEmpty(Stack* obj)
{
    return obj->top == -1;
}

void reverse(char* data, int length)
{
    int left = 0;
    int right = length - 1;
    while (left <= right) {
        char tmp = data[left];
        data[left] = data[right];
        data[right] = tmp;
        left++;
        right--;
    }
}

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    Stack* obj1 = CreateStack();
    Stack* obj2 = CreateStack();
    int data = 0;
    while (l1 != NULL && l2 != NULL) {
        data += (l1->val + l2->val) % 10;
        PushStack(obj1, data);
        data = 0;
        data += (l1->val + l2->val) / 10;
        l1 = l1->next;
        l2 = l2->next;
    }
    if (l1 == NULL && l2 == NULL) {
        if (data == 1) {
             PushStack(obj1, data);
        }
    } else {
        int tmp = 0;
        while (l1 != NULL) {
            tmp += (data + l1->val) % 10; // 第二次就不能使用 data 加了这里应该使用 tmp.
            PushStack(obj1, tmp);
            printf("\n %d", tmp);
            tmp = 0;
            tmp += (data + l1->val) / 10;
            l1 = l1->next;
        }

        while (l2 != NULL) {
            tmp += (data + l2->val) % 10;
            PushStack(obj1, tmp);
            tmp = 0;
            tmp += (data + l2->val) / 10;
            l2 = l2->next;
        }    
        if (l1 == NULL && l2 == NULL && tmp != 0) {
            PushStack(obj1, tmp);
        }
    }


    while (!IsStackEmpty(obj1)) {
        int data = PopStack(obj1);
        PushStack(obj2, data);
    }
    struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->next = NULL;
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->next = NULL;
    head = dummy;
    dummy->val = PopStack(obj2);
    while (!IsStackEmpty(obj2)) {
        dummy->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        dummy->next->val = PopStack(obj2);
        dummy->next->next = NULL;
        dummy = dummy->next;
    }
    return head;
}

```
