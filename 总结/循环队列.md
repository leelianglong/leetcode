### 一个简单实现

```
#include "queue.h"
#include <stdio.h>
#include <stdlib.h>

void InitQueue(Queue *q) {
	q->base = (Item*)malloc(MAXQSIZE * sizeof(Item));
	if (q->base == NULL)
		exit(OVERFLOW);
	q->front = 0;
	q->rear = 0;
}

/*return the length of the queue*/
unsigned int QueueLength(Queue q) {
	return (q.rear - q.front + MAXQSIZE) % MAXQSIZE;
}
/*Destroy the queue*/
void DestroyQueue(Queue *q) {
	q->base = NULL;
	q->rear = 0;
	q->front = 0;
	free(q->base);
}

/*determine if the queue is empty*/
bool IsEmpty(Queue q) {
	return q.rear == q.front;
}

bool IsFull(Queue q) {
	return (q.rear + 1) % MAXQSIZE == q.front;
}

/*return the head elem of the queue*/
Item Top(Queue q) {
	return q.base[q.front];
}

/*return the back elem of the queue*/
Item Back(Queue q) {
	return q.base[(q.rear - 1 + MAXQSIZE) % MAXQSIZE];
}

/*enqueue, insert the rear*/
bool EnQueue(Queue *q, Item e) {
	if (IsFull(*q))
		return ERROR;
	q->base[q->rear] = e;
	q->rear = (q->rear + 1) % MAXQSIZE;
	
	return OK;
}
/*dequeue, pop the front*/
bool DeQueue(Queue *q) {
	if(IsEmpty(*q))
		return ERROR;
	q->front = (q->front + 1) % MAXQSIZE;
	return OK;
}

/*print the queue*/
void PrintQueue(Queue q) {
	int i, j;
	for (i = 0, j = q.front; i < QueueLength(q); i++, j = (j + 1) % MAXQSIZE) {
		printf("%d\n",q.base[j]);
	}
}
————————————————
版权声明：本文为CSDN博主「perry0528」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/perry0528/java/article/details/81990242
```

下面的实现还有问题：
```

typedef struct {
    int size;
    int front;
    int rear;
    int* data;  
} MyCircularQueue;

bool myCircularQueueIsEmpty(MyCircularQueue* obj);
bool myCircularQueueIsFull(MyCircularQueue* obj);

/** Initialize your data structure here. Set the size of the queue to be k. */

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* tmp = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    memset(tmp, 0, sizeof(MyCircularQueue));
    tmp->data = (int*)malloc(sizeof(int) * k);
    memset(tmp->data, 0, sizeof(int) * k);
    tmp->front = 0;
    tmp->rear = 0;
    tmp->size = k;
    return tmp;
}

/** Insert an element into the circular queue. Return true if the operation is successful. */
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    printf("\nEN: %d %d\n", obj->front , obj->rear);
    if (myCircularQueueIsEmpty(obj)) {
        obj->data[obj->front] = value; // 初始的0放在front上。
        return true;
    }
    
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    
    obj->rear = (obj->rear + 1) % obj->size; // 如果再有元素要入队，就先加，然后判断是否满了，再把元素放到队列中。
    if (obj->rear == obj->front) {
        return false;
    }
    obj->data[(obj->rear)] = value;
    return true;
}

/** Delete an element from the circular queue. Return true if the operation is successful. */
bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->data[obj->front] = -1;
    if (obj->front != obj->rear) {
        obj->front++;
    }
    //obj->front = (obj->front + 1) % obj->size;
    printf("\nDE: %d %d\n", obj->front , obj->rear);
    return true;
}

/** Get the front item from the queue. */
int myCircularQueueFront(MyCircularQueue* obj) {
    printf("\nfront=%d\n", obj->front);
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

/** Get the last item from the queue. */
int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->rear];
}

/** Checks whether the circular queue is empty or not. */
bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    if (obj->front == obj->rear && obj->data[obj->front] == -1) { // 这里-1的作用在于，上面入队的方式，存在 front = rear = 0时，有个元素入队了。
        return true;
    }
    return false;
}

/** Checks whether the circular queue is full or not. */
bool myCircularQueueIsFull(MyCircularQueue* obj) {
    if (obj->front == (obj->rear + 1) % obj->size) { // 满
        return true;
    }
    return false;
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);   
}
```
