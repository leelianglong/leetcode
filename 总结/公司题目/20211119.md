#### 题目1
##### 给定输入
1. price 数组，price[i] 表示第i个商品的单价。
2. promotions数组是促销的条件[[0,7], [1,10,3,9],[7,8]] 具体含义是，第0种商品买7件才有优惠； 第1中商品买10件，并且第3种商品买9件，只有满足这种组合的时候才能够享受优惠； 第7种商品买8件才能够优惠。
3. discount数组，这个数组和2中的是对应的。表示满足促销条件后能够优惠的钱数。discount[10,9,8], 表示满足0种商品买的超过7件，就优惠10元；1号商品超过10件，3号商品超过9件享受9元优惠，第7号商品超过8件优惠8元。
4. order数组是订单信息[6,7,2,6,0,10],  Oder[i] 表示第几号商品，order[i + 1] 表示要买多少件
#### 求order中这些商品要花多少钱。
1. 注意1种商品只能参加一个优惠活动；
2. 顾客尽可能多的参加优惠活动。关键点：优惠条件中有多种货物时，要都满足才能享受优惠。单个满足不能享受优惠。




#### 题目2
#### 给定输入
1. 给定数组 [0, 0, 1, 3] 表示tokenID是0， 从0时刻其，每个1秒中产生3个token。 实现接口bool addRule(int id, int time, int interval, int number) .如果列表中已有相同的ID则返回false。如果没有则添加成功。添加时刻就要生成number个token

2. 给定数组 [0, 1] 表示tokenID 0， 在1时刻删除，注意，如果是正在产生token的时间，则先产生token后，在删除实现接口bool remove(int id, int time)

3. 给定数组 [4, 10] 表示时刻4，来了10个包，需要实现接口判断能不能把这些包转发出去。如果当前时间是产生token的时间先产生token，如果当前令牌总数大于要转发的包数，则转发成功返回true，总的token数减少，否则返回false。总的token数不变。 实现接口 bool transformdata(int time, int size)

4. 查询当前token数量，如果当前时间产生token，先产生后再计算。 query(int time);


#### 题目3
##### 给定输入
1. 数组[[1,5,6], [3,6,8],[10,11,4]]  这里三元组表示一个积木开始位置，结束位置，搬移这个积木所话时间。给定这样的数组，如果积木有重叠则往上重。
2. 给定一个时间限制limit。需要计算这个limit中最大能够搬移几块积木。注意搬移积木的原则是只能搬移它上面没有重叠的。
