### 题目2

给定值和其父节点的关系，[[1,3],[2,3],[3,-1],[4,1],[5,2]]其中没有父节点的为-1.优先拼接左子树，返回构造树的根节点。

下面的代码有内存问题。
### 代码
```
int FindRoot(int** relations, int relationsSize, int* relationsColSize, int* pos)
{
    for (int i = 0; i < relationsSize; i++) {
        if (relations[i][1] == -1) {
            *pos = i;
            return relations[i][0];
        }
    }
    return -1;
}

void step(struct TreeNode* root, int** relations, int relationsSize, int* visted)
{
    if (root == NULL) {
        return;
    }
    bool flg = false;
    for (int i = 0; i < relationsSize; i++) {
        if (relations[i][1] == root->val && visted[i] == 0 && flg == false) {
            visted[i] = 1;
            root->left = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            root->left->val = relations[i][0];
            step(root->left, relations, relationsSize, visted);
            flg = true;
            continue;
        }
        if (relations[i][1] == root->val && visted[i] == 0) {
            visted[i] = 1;
            root->right = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            root->right->val = relations[i][0];
            step(root->right, relations, relationsSize, visted);
        }
    }
}

#define NODE_COUNTER 1000

struct TreeNode* BuildTree(int** relations, int relationsSize, int* relationsColSize)
{
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->left = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->right = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    int pos = 0;
    root->val = FindRoot(relations, relationsSize, relationsColSize, &pos);
    int* visited = (int*)malloc(sizeof(int) * relationsSize);
    (void)memset_s(visited, sizeof(int) * relationsSize, 0, sizeof(int) * relationsSize);
    visited[pos] = 1;

    step(root, relations, relationsSize, visited);

    return root;
}
```

```

typedef struct {
    int parent;
    int child[2];
} Relations;

#define NODE_COUNTER 1000
Relations* FindRelations(int** relations, int relationsSize, int* relationsColSize, int* rootPos)
{
    Relations* tmpSave = (Relations*)malloc(sizeof(Relations) * NODE_COUNTER);
    memset(tmpSave, 0, sizeof(Relations) * NODE_COUNTER);

    for (int i = 0; i < relationsSize; i++) {
        tmpSave[i].parent = relations[i][1];
        tmpSave[i].child[0] = relations[i][0];
        if (tmpSave[i].parent == -1) {
            *rootPos = i;
        }
    }
    return tmpSave;
}

#define QUEUE_SIZE 10000
struct TreeNode* BuildTree(int** relations, int relationsSize, int* relationsColSize)
{
    int rootPos = 0;
    Relations* tmp = FindRelations(relations, relationsSize, relationsColSize, &rootPos);

    Relations* queue = (Relations*)malloc(sizeof(Relations) * QUEUE_SIZE);
    memset(queue, 0, sizeof(Relations) * QUEUE_SIZE);
    bool visit[QUEUE_SIZE] = {false};
    int front = 0;
    int rear = 0;
    queue[rear++] = tmp[rootPos];

    struct TreeNode* root = NULL;
    while (front != rear) {
        int curSize = rear - front;
        for (int i = 0; i < curSize; i++) {
            Relations curNode = queue[front++];
            root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            if (curNode.parent == -1) {
                curNode.parent = curNode.child[0];
            }
            root->val = curNode.parent;
            root->left = NULL;
            root->right = NULL;
            for (int k = 0; k < relationsSize; k++) {
                if (tmp[k].parent == curNode.parent && visit[k] == false) {
                    visit[k] = true;
                    if (root->left == NULL) {
                        root->left = (struct TreeNode*)malloc(sizeof(struct TreeNode));
                        root->left->val = tmp[k].child[0];
                        root->left->left = NULL;
                        root->left->right = NULL;
                    } else {
                        root->right = (struct TreeNode*)malloc(sizeof(struct TreeNode));
                        root->right->val = tmp[k].child[0];
                        root->right->left = NULL;
                        root->right->right = NULL;
                    }
                    queue[rear++] = tmp[k];// 入队。
                }
            }
        }
    }
    return root;
}


int main() {
    printf("Hello, World!\n");
    int test[5][2] = {
            {1,3}, {2,3}, {3, -1}, {4, 1}, {5, 2}
    };
    int** test1 = (int**)malloc(sizeof(int*) * 5);
    for (int k = 0; k < 5; k++) {
        test1[k] = (int*)malloc(sizeof(int) * 2);
    }

    for (int i = 0; i < 5; i++) {
        for (int k = 0; k < 2; k++) {
            test1[i][k] = test[i][k];
        }
    }
    int relationsColSize = 2;
    struct TreeNode* result = BuildTree(test1, sizeof(test) / sizeof(test[0]), &relationsColSize);

    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000);
    memset(queue, 0, sizeof(struct TreeNode*) * 1000);
    int front = 0;
    int rear = 0;

    queue[rear++] = result;
    while (front != rear) {
        int curSize = rear - front;
        for (int k = 0; k < curSize; k++) {
            struct TreeNode* curNode = queue[front++];
            printf("%d", curNode->val);
            if (curNode->left) {
                queue[rear++] = curNode->left;
            }
            if (curNode->right) {
                queue[rear++] = curNode->right;
            }
        }
        printf("\n");
    }

    return 0;
}
```
### 题目3

给定一串数字，找到其中2个数字，这2个数字把这串数字分成3个部分，每个部分的和相等，返回这个2个数字的下标。

