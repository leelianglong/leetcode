### 题目2

给定值和其父节点的关系，[[1,3],[2,3],[3,-1],[4,1],[5,2]]其中没有父节点的为-1.优先拼接左子树，返回构造树的根节点。

下面的代码有内存问题。
### 代码
```
int FindRoot(int** relations, int relationsSize, int* relationsColSize, int* pos)
{
    for (int i = 0; i < relationsSize; i++) {
        if (relations[i][1] == -1) {
            *pos = i;
            return relations[i][0];
        }
    }
    return -1;
}

void step(struct TreeNode* root, int** relations, int relationsSize, int* visted)
{
    if (root == NULL) {
        return;
    }
    bool flg = false;
    for (int i = 0; i < relationsSize; i++) {
        if (relations[i][1] == root->val && visted[i] == 0 && flg == false) {
            visted[i] = 1;
            root->left = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            root->left->val = relations[i][0];
            step(root->left, relations, relationsSize, visted);
            flg = true;
            continue;
        }
        if (relations[i][1] == root->val && visted[i] == 0) {
            visted[i] = 1;
            root->right = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            root->right->val = relations[i][0];
            step(root->right, relations, relationsSize, visted);
        }
    }
}

#define NODE_COUNTER 1000

struct TreeNode* BuildTree(int** relations, int relationsSize, int* relationsColSize)
{
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->left = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->right = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    int pos = 0;
    root->val = FindRoot(relations, relationsSize, relationsColSize, &pos);
    int* visited = (int*)malloc(sizeof(int) * relationsSize);
    (void)memset_s(visited, sizeof(int) * relationsSize, 0, sizeof(int) * relationsSize);
    visited[pos] = 1;

    step(root, relations, relationsSize, visited);

    return root;
}
```

### 题目3

给定一串数字，找到其中2个数字，这2个数字把这串数字分成3个部分，每个部分的和相等，返回这个2个数字的下标。

