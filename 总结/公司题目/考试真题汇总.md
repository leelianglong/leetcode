### 1、 https://leetcode-cn.com/problems/merge-two-sorted-lists/

### 2、 https://leetcode-cn.com/problems/design-log-storage-system/
```
一个日志系统生成一种格式的日志，日志有两个数据，一个是日志的id，一个是日志的时间戳timestamp，日志的id不会重复，时间戳有可能相同；现在要求记录这些日志，
实现如下三个操作函数：
(1) 添加一条日志，接口函数 void Add(int id, int timestamp)
(2) 删除一条日志，如果日志不存在返回-1，删除成功返回0，接口函数 int Delete(int id)
(3) 查询一段时间内（包含两个时间点）生成了多少条日志，接口函数 int Query(int startTime, int endTime)

```

### 3、 https://leetcode-cn.com/problems/corporate-flight-bookings/

### 4、https://leetcode-cn.com/problems/design-file-system/

```
该题目参考下面博客:
https://www.cnblogs.com/grandyang/p/6944331.html
```

### 5、
```
1、 实验室有一排服务器，每个服务器都有一个序列号，序列号可以相同，每个服务器放在一个座位上，现在要求你将服务器按照序列号从小到大的顺序摆放好，
每个位置只能放一个服务器，请问需要挪动多少个服务器。
例如:
输入：[1, 1, 1, 4, 3, 2]
输出：2
解释：只需将服务器4和服务器2的位置对换一下即可，即需要移动2个服务器。

```

### 6、
```
给你两个数n和m，且1<=n<=m<=2^(31) - 1，求在n和m之间存在多少个位数为偶数的数（包括n和m）。位数为偶数是指按照十进制的计算方式，其数所占的位数，如18，99是一个两位数，即为位数为偶数的数，1000，1932为4位数，即满足要求。3，100,10923位数为奇数，都不满足要求。
例如：
输入：1, 18
输出：9
解释：在1至18之间，一共有10,11,12,13,14,15,16,17,18满足要求，共9个数
```

```
 一现在有一辆救护车上有一个急救病人需要快速送去医院，但是该城市的有些道路处于拥堵状态且不能通过。为了能尽快将病人送到医院，救护车可以联系交警部门，
 将一个拥堵路段清理成空闲状态且最多清理一个拥堵路段。该城市的道路使用一个矩阵来表示，矩阵中标记为0的表示该道路处于空闲状态，标记为1的表示处于拥堵状态
 ，救护车到医院的时间使用距离来衡量，在矩阵中走一个方格代表行驶一公里，且只能上下左右走，到医院的所行驶的距离越小即代表所需要的时间越少。
 给定该城市各道路的状态（矩阵图），救护车（起始坐标）和医院（终点坐标）的位置，请问救护车在交警的协助下，最少需要走多少公里才能到达医院。如果能到达，
 输出最小的距离，如果不能到达，输出-1。矩阵的范围不超过100*100，拥堵路段的点数不超过50。
例1：
输入：[[0,0,1,0],[0,0,0,0]], start:(0,0), end:(0,3)
输出：3
解释：交警可以将（0,2）拥堵路段清理为空闲状态，start到end的最小距离为3
 
例2：
输入：[[0,1,1,0],[1,0,0,0]], start:(0,0), end:(0,3)
输出：5
解释：交警可以将（1,0）拥堵路段清理为空闲转态，此时start到end的最小距离为5
 
例3：
输入：[[0,1,1,0],[1,1,0,0]], start:(0,0), end:(0,3)
输出：-1
解释：清理一个拥堵路段为空闲转态之后，救护车还是无法到达医院，所以输出-1

```

```
你有 N 个由小写字母组成的非空字符串列表 strings。你需要在这些字符串中选出 M 组，每组三个，记为S[0], S[1], ... S[3M-1]，满足：每组字符串存在公共前缀，且该前缀非空。每组前缀互不相同，请找出 M 的最大值。
限制：1<=N<=1000， 1<= strings中每个字符串的长度<=50
例1：
输入：strings = ["leetcode", "leet", "happycode", "lee"]
输出：1
解释：我们可以取["leetcode", "leet","lee"]，并令公共前缀为"l"或"le"或"lee"。
 
例2：
输入：strings = ["l", "la", "lb", "lx", "lxa", "lxb"]
输出：2
解释：我们可以取["l", "la", "lb"]，并令它们公共前缀为"l";然后取["lx", "lxa", "lxb"]，并令它们公共前缀为"lx"。故最多是两组。
 
例3：
输入：strings = ["l", "la", "lb", "lc", "ld", "le"]
输出：1
解释：这些字符串两两都只有一个公共前缀"l"。因为公共前缀需要保证唯一，我们只能取出一组

```

```
有一个单向链表（头节点为head ），现对它进行简单加密，加密算法：给定一个秘钥数字K，把从前向后数第k个元素与从后向前数第k个元素进行交换。现在请你完成这个加密。说明：单链表的节点位置是从1开始（不是0开始）。限制：链表至少有一个元素，最多有 10000 个元素。1<=k<=链表长度。
例3：
输入：head = [1,2,3,4,5,6], k = 2
输出：[1,5,3,4,2,6]

```

### 题目：
https://leetcode-cn.com/problems/degree-of-an-array

```
https://leetcode-cn.com/problems/next-greater-element-ii/

给定一个正整数数组nums，其按照时间顺序记录了数个同类任务的完成时长（单位为周），为了更准确评估该类任务的工作量，现做如下分析，找出每个任务的前面、比当前任务完成时长短的邻近时长，如果无法找到则记为 -1。将这些邻近时长记录成一个新数组并返回。
例1：
输入：nums = [1,6,4,10,2,5]
输出：[-1,1,1,4,1,2]
解释：第一个任务时长记录（1）左边没有记录，返回-1。第二个任务时长记录（6）左边只有一个比该时长更短的任务时长（1），所以返回1。第四个任务时长记录（10）左边有三个比该时长更短的时长记录（1，6，4），所以返回最邻近的4。
例2：
输入：nums = [ 2, 4, 1, 3, 6]
输出：[ -1, 2, -1, 1, 3 ]
解释：第三个任务时长记录（1）左边没有比该时长更短的时长记录，（左边时长记录2，4均比1长），故返回-1
```

```
https://leetcode-cn.com/problems/meeting-rooms-ii （类似题）
某设备有一个线程池调度特性，现给一个任务安排的时间数组，每个任务时间都会包括开始和结束的时间[[s1, e1], [s2, e2], ...] (si < ei)，为避免线程冲突，并充分利用线程池的资源，请你给调度特性计算至少需要使用池中的多少个线程，才能满足这些任务执行。
例1：
输入：nums = [[0, 30],[5, 10],[15, 20]]
输出：2
解释：任务0的时间周期为[0, 30]，独占一个线程；任务1使用另一个线程，等任务结束后，可以继续执行任务2。所以，合计使用2个线程即可。
```

```
由空地和围墙组成的专用场地（网格形状）中，有一个自动驾驶汽车要做专项模拟测试。假设：车可以向上（u）下（d）左（l）右（r）四个方向行驶，但在撞到围墙之前不会停止行驶。当车停下时，则可以选择下一个方向。场地中还有一个目的地，当车行驶经过目的地时，就会停下来。给定车的起始位置，目的地和专用场地，找出让车以最短距离行驶到目的地的路径。距离的定义是车从起始位置（不包括）到目的地（包括）经过的空地个数。通过'u', 'd', 'l' 和 'r'输出车的移动方向。由于可能有多条最短路径， 请输出字典序最小的路径。如果车无法到达目的地，则输出"impossible"。专用场地由一个0和1组成的二维数组表示。1表示围墙，0表示空地。你可以假定专用场地的边缘都是围墙。起始位置和目的地的坐标通过行号和列号给出。
注意: 场地中只有一个车和一个目的地。车和目的地都在空地上，且初始时它们不在同一位置。给定的专用场地不包括边界 (如图中的红色矩形), 但你可以假设专用场地的边缘都是墙壁。专用场地至少包括2块空地，行数和列数均不超过30。字典序是指按照单词出现在字典的顺序进行排序的方法。先按照第一个字母、以 a、b、 c......z的顺序排列;如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长(比如，sigh 和sight)，那么把短者排在前。
例1：
输入：专用场地由以下二维数组表示：
0  0  0  0  0
1  1  0  0  1
0  0  0  0  0
0  1  0  0  1
0  1  0  0  0
车的初始位置 (rowCar, colCar) = (4, 3)
目的地的位置 (rowDes, colDes) = (0, 1)
输出："lul"
解释：有两条让车到达目的地的最短路径。第一条路径是 左 -> 上 -> 左, 记为 "lul"（第一步向左，碰到墙后停下来，再转向上，一直向上碰到墙后停下来，然后再向左转即达到目的地）, 第二条路径是 上 -> 左, 记为 'ul'. （第一步向上，碰到墙后停下来，再转左即可到达目的）， 两条路径都具有最短距离6, 但'l' < 'u'，故第一条路径字典序更小。因此输出"lul"。
 
例2：
输入：专用场地由以下二维数组表示：
0  0  0  0  0
1  1  0  0  1
0  0  0  0  0
0  1  0  0  1
0  1  0  0  0
车的初始位置 (rowCar, colCar) = (4, 3)
目的地的位置 (rowDes, colDes) = (3, 0)
输出："impossible"
解释：车无法到达目的地。
```

```
 https://leetcode-cn.com/problems/reverse-words-in-a-string/（类似题）
英文单词一般首字母大写，之后小写，给定一个字符串，包含大小写，逐个反转每个单词。
例1：
输入："MyNameIsTom"
输出："yMemaNsImoT"
 
例2：
输入："TomLL"
输出："moTLL"
```

```
2、 https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/
3、 https://leetcode-cn.com/problems/course-schedule-ii/

```

```
1、 https://leetcode-cn.com/problems/single-row-keyboard/（会员题）
2、 公司开发部门团建时，你被邀请参与一个小游戏。游戏开始时，你们会获得一个大小为 n x m 的矩阵 matrixA。游戏的规则为：你们每个人都需要计算出一个和矩阵 matrixA 具有相同维度的矩阵 matrixB（即矩阵 matrixB 的大小也为 n x m），而矩阵 matrixB 中的每个元素 matrixB[i, j] 都对应了矩阵 matrixA 中元素 matrixA[i, j] 左上方（包含 matrixA[i, j] ）的所有元素之和。返回正确答案最快的玩家将会获奖。该游戏有若干轮，你决定编写一个程序来代替纸笔计算。请尝试编写这个程序帮助你计算结果。
例1：
输入：matrixA = [ [ 3,  7,  1],
[ 2,  4,  0],
[ 9,  4,  2] ]
输出：matrixB = [ [ 3, 10, 11],
[ 5, 16, 17],
[14,29, 32] ]
解释：matrixB [1,1] = 3 + 2 + 7 + 4 = 16
 
3、 https://leetcode-cn.com/problems/koko-eating-bananas/

```

```
1、 https://leetcode-cn.com/problems/permutation-in-string/
2、 https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/（类似题）
采购团队的负责人正在进行信息统计，数组 arr 中存放了该采购团队本月的支出款项。负责人需要找出每个数据（arr[i]）之前（不包含该数据）小于等于它的款项，计算出这些数据的和。请你帮他设计一个高效算法统计出它们的总和。
答案需要取模 1e9 + 7 (1000000007)，如：计算初始结果为：1000000008，请返回 1。
例1：
输入：arr = [1,3,5,2,4,6]
输出：27
解释：用 f(i) 表示在 arr[i] 之前，小于等于 arr[i] 的款项之和，则f(0) = 0, f(1) = 1, f(2) = 1 + 3 = 4, f(3) = 1, f(4) = 1 + 3 + 2 = 6, f(5) = 1 + 3 + 5 + 2 + 4 = 15，加起来等于 27
3、 公有云联合WPS推出在线表格 WeWps 功能，具体功能如下：
 
WeWps(int height, char width): 构造函数，输入为 WeWps 的高度和宽度。height 是一个正整数，范围从 1 到 26，代表高度。width 是一个字符，范围从 'A' 到 'Z'，宽度等于从 'A' 到 width 的字母个数。WeWps 表格是一个高度 * 宽度的二维整数数组，数组中元素初始化为 0。第一行下标从 1 开始，第一列下标从 'A' 开始。
 
void Set(int row, char column, int val): 设置 C(row, column) 中的值为 val。
 
int Get(int row, char column): 返回 C(row, column) 中的值。
 
int Sum(int row, char column, List of Strings : numbers): 这个函数会将计算的结果放入 C(row, column) 中，计算的结果等于在 numbers 中代表的所有元素之和，这个函数同时也会将这个结果返回。求和公式会一直计算更新结果直到这个公式被其他的值或者公式覆盖。
 
numbers 是若干字符串的集合，每个字符串代表单个位置或一个区间。如果这个字符串表示单个位置，它的格式如下：ColRow，例如 "F7" 表示位置 (7, F) 。如果这个字符串表示一个区间，它的格式如下：ColRow1:ColRow2。区间就是左上角为 ColRow1 右下角为 ColRow2 的长方形。
 
例1：
WeWps(3,"C");
// 构造一个 3*3 的二维数组，初始化全是 0。
//   A B C
// 1 0 0 0
// 2 0 0 0
// 3 0 0 0
 
Set(1, "A", 2);
// 设置 C(1,"A") 为 2。
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 0
 
Sum(3, "C", ["A1", "A1:B2"]);
// 将 C(3,"C") 的值设为 C(1,"A") 单点，左上角为 C(1,"A") 右下角为 C(2,"B")。
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 4
// sum 值 = C(1,"A") + C(A1:B2)
 
Set(2, "B", 2);
// 将 C(2,"B") 设为 2。 注意 C(3, "C") 的值也同时改变。
//   A B C
// 1 2 0 0
// 2 0 2 0
// 3 0 0 6
说明 ：
你可以认为不会出现循环求和的定义，比如说： A1 = sum(B1) ，B1 = sum(A1)。
测试数据中，字母表示用双引号。
请记住清零 WeWps 类中的变量，因为静态变量、类变量会在多组测试数据中保存之前结果。
函数 / 类的调用方式（以C语言为例，其他语言参考）：
/*
 * WeWps* obj = WeWpsCreate(height, width);
 * WeWpsSet(obj, row, column, val);
 * int param_2 = WeWpsGet(obj, row, column)
 * int param_3 = WeWpsSum(obj, row, column, strs, strsSize);
 * WeWpsFree(obj);
 */
需要实现的接口：
class WeWps {
public:
    WeWps(int height, char width)
    {
    }
    void Set(int row, char column, int val)
    {
    }
    int Get(int row, char column)
    {
    }
    int Sum(int row, char column, vector<string> strs)
    {
    }
};

```

```
1、 某运营商客户要在一小镇新建一批基站，经过专家勘测得到一批适合建设基站的地点列表 positions，考虑到经济原因，需要从中找出距离小镇最近的 num 个点建立基站。地点的坐标为平面坐标，小镇的坐标为原点 (0,0)。输出：请返回符合要求的 num 个站点坐标的列表。列表中的坐标可以按照任何顺序排列；用例会保证解是唯一的，不存在多个解。提示：1 <= num <= positions.length <= 10000，-10000 < positions[i][0] < 10000，-10000 < positions[i][1] < 10000。
例1：
输入：positions = [[1,3],[-2,2]], num = 1
输出：[[-2,2]]
解释：(1, 3) 和原点之间的距离为 sqrt(10)，10 = 1^2 + 3^2，(-2, 2) 和原点之间的距离为 sqrt(8)，8 = (-2)^2 + 2^2，(-2, 2) 比 (1, 3) 站点离原点的距离更近。我们只需要距离原点最近的 num = 1 个点，所以答案就是 [[-2,2]]。
例2：
输入：positions = [[3,3],[5,-1],[-2,4]], num = 2
输出：[[3,3],[-2,4]] （答案 [[-2,4],[3,3]] 也会被接受。）
2、 某企业行业客户是高铁公司，其要在一条高铁线路的沿途安装一些摄像头，假设共有 n 个点需要安装，每个摄像头安装点的位置记录在 sites 数组中。在此线路的沿途设置了一些供给点（放置如工具或配件的小仓库），每个供给点的位置记录在 stores 数组中，用于放置一些这次安装摄像头所需的零配件。假设所有安装点（sites）和供给点（stores）都在一条数轴（原点为 0）上，为了方便安装工人走最近的距离拿到所需的工具或配件，请计算出距离每个安装点最近的供给点位置（如果找到多个符合要求的供给点，则返回距离数轴原点最近的那个即可），并返回这些供给点位置的列表。
1<= m, n <= 50000，1 <= stores[i] <= 1e9，1 <= sites[i] <= 1e9，少量性能用例，容易超时。
例1：
输入：stores = [1, 5, 20, 11, 16], sites = [5, 10, 18]
输出：[5,11,16]
解释：距离 5 最近的是 5，距离 10 最近的是11，距离 18 最近的是 16 和 20，取较小的 16。
例2：
输入：stores = [1, 5], sites = [5, 10, 18]
输出：[5,5,5]
3、 公司 IT 防攻击小组在做一次专项分析，由于受到干扰，本应接收到的一组 ip 地址（IPv4）信息被合并成一条长信息且缺失了部分内容。为了判断缺失情况，请你帮忙解析出字符串 str 形式的长信息中所有合法 ip 地址的个数，解析出的相同地址需要进行去重。字符串长度 <= 100000，字符串由数字（’0’ - ‘9’）以及 ‘.’ 组成，假设 IPv4 合法地址的规则如下：
（1）    采用 "." 分隔成四个字段，每个字段采用十进制记录。
（2）    每个字段的值范围为：[0,255]。
（3）    每个字段的值除了 0 外，其他情况首位不可为 0。如：0.0.0.0 合法，0.01.0.1 不合法。
例1：
输入：str = "1.1.1111.16..172.16.254.1.1"
输出：5
解释：字符串 str 可能被分为："172.16.254.1", "72.16.254.1", "2.16.254.1", "16.254.1.1", "6.254.1.1"
例2：
输入：str = "1.2.3.04"
输出：1
解释：字符串 str 只可能被分为 "1.2.3.0"

```

```
1、 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/（类似题，比考试题稍简单）
终端某合作经销商遇到一个烦恼，由于下半年各平台的打折活动频繁，其终端商品价格具有一定波动性。经销商为了保证获取最大利益，将该商品在连续的 K 天内的价格记录在了数组 price 中 。经销商在某天（设为 i）决定购入某商品，将它们存入仓库。并在另外一天（设为 j），经销商将商品卖出（i <= j），同时他还需要付给该仓库 j - i 元的租金（每天租金为 1）。此经销商请你帮忙判断一下基于现在的规则，最多可以赚多少利润，并输出。注：为了简化实现，整个过程只买卖一次。1 <= K <= 50000，1 <= price[i] <= 300。
例1：
输入：price = [2,1,5]
输出：3
解释：最优策略是第二天买入，第三天卖出，租金为 1，利润为 5 - 1 - 1 = 3
例2：
输入：price = [7,6,5]
输出：0
解释：最优策略是任意一天买入，当天卖出，利润为 0
3、 https://leetcode-cn.com/problems/maximum-equal-frequency/
```

```
1、 公有云中某 3 个数据中心 11 月份产生的告警类型（整数）分别记录在3个数组： array1，array2 和 array3 中，并且严格递增排列。请你找出 3 个数据中心产生的共性告警（即：在 3 个数组中都存在的告警类型），并按照升序排列返回。
1 <= array1.length,  array2.length,  array3.length <= 1000，1 <= array1[i],  array2[i],  array3[i] <= 2000。
例1：
输入：array1 = [1,2,3,4,5], array2 = [1,2,5,7,9], array3 = [1,3,4,5,8]
输出：[1, 5]
解释：只有 1 和 5 同时在这三个数组中出现。
2、 测试工程师正在测试某款新型扫地机器人。工程师设计了一个形如二叉树（根节点记为 root）的测试路径，扫地机器人自路径对应的根节点出发，一直行进至路径尽头（即二叉树叶节点）。如果这个路口的左右子节点都非空，机器人选择左转或右转的概率相等；如果这个路口的左右子节点仅一侧非空，则机器人选择非空侧走。工程师给每个路口标记了数字，并且仅在标记数字 target 的所有路口设置了监控摄像机。请问扫地机器人被监控至少拍到一次的概率是多少？1 <= 树的节点数 <= 10000。
例1：
输入：root = [1, 2, 3, 2, 5, 6, 2],  target = 2
输出：0.75
解释：数组按二叉树层次遍历的顺序记录了标记数字。从 1 出发，从左侧走到 2 的概率为 0.5（被拍到）, 从右侧走到 3 的概率为 0.5, 从 3 继续出发，走到 2 的概率为 0.5（被拍到），所以结果为 0.5 + 0.5 * 0.5 = 0.75。
即：左侧分支被拍到的概率为 0.5（红色圈的 2 是 0.5，继续走到 2 或 5，不会增加被拍概率，也不会降低被拍概率），右侧分支被拍到的概率为 0.25（红色圈的 2），合计为 0.75。
例2：
输入：root = [1, null, 3, 2, 2],  target = 2
输出：1
3、 根据输入字符串，按规则进行 TLV 编码。规则如下：
所有字符均为数字，则类型(T)为 1，进行5421压缩编码(下有解释），长度(L)和内容(V)用来描述编码后的二进制码流。其他所有输入均按字符串处理，类型(T)为2，长度(L)和内容(V)用来描述该字符串，L和V中均不包括结束符。
输出为 TLV 字节码流，要求：前 2 字节为类型（T），接下来 4 字节为长度（L），后续为内容（V），字节序使用网络序（大端）。
5421压缩编码：指用 4 bit 来描述单个十进制数字，每个bit的权重分别为5/4/2/1，编码后每个字节可以描述两个十进制数字；奇数位数字，高位补 0 后参与编码。
举例：
45 -> 0x48
456 -> 0x04 0x89
输入：输入为单行字符串，不包含换行符。用例保证输入字符串长度范围 [0,255]。
输出：输出为码流字符串：码流中每个字节由十六进制两位数表示，字母a-f小写，码流字节间，由单个空格分隔。行末无空格。
例1：
输入："456"
输出："00 01 00 00 00 02 04 89"
例1：
输入："abc"
输出："00 02 00 00 00 03 61 62 63"
```
```
1、 https://leetcode-cn.com/problems/maximum-frequency-stack/（类似题，背景一致，考察点略有差别）
堆栈是一种经典的后进先出的线性结构，相关的操作主要有“入栈”（在堆栈顶插入一个元素）和“出栈”（将栈顶元素返回并从堆栈中删除）。现在请你实现一种特殊的功能，赋予它“查询中值”的操作，规则如下：对于含N个元素堆栈结构，若N是偶数，则中值定义为该序列中第N/2个小的值；若N是奇数，则中值定义为该序列中第(N+1)/2个小的值。1 <= value <= 10^6，最多会对 Pop、Push、PeekMedian进行 10^5 次调用。性能用例较少。
（1） Push(value) - 入栈，堆栈添加新的元素value
（2）Pop() - 出栈，若堆栈非空，返回栈顶元素；否则返回 -1
（3）PeekMedian() - 计算中值，若堆栈非空，返回当前堆栈的中值；否则返回-1（注意：仅仅是查值，不需要弹出）。
例1：
输入：["StackSystem","Push","Push","Push","Push","Pop","PeekMedian"]
[ [], [4], [3], [5], [6], [], [] ]
输出：[null, null, null, null, null, 6, 4]
解释：StackSystem s = StackSystem()
s.Push(4)       // 堆栈增加元素4，当前堆栈[4]
s.Push(3)       // 堆栈增加元素3，当前堆栈[4,3]
s.Push(5)       // 堆栈增加元素5，当前堆栈[4,3,5]
s.Push(6)       // 堆栈增加元素6，当前堆栈[4,3,5,6]
s.Pop()          // 返回栈顶元素6, 剩余堆栈[4,3,5]
s.PeekMedian() // 当前堆栈[4,3,5], (3+1)/2=2，中值是第2小的元素，故返回4
例2：
输入：["StackSystem","Pop","PeekMedian","Push","Push","Push","Push","Push","PeekMedian"]
[ [], [], [], [3], [4], [4], [5], [5], [] ]
输出：[null, null, null, null, null, 6, 4]
解释：StackSystem s = StackSystem()
s.Pop()          // 当前堆栈为空，返回-1
s.PeekMedian() // 当前堆栈为空，返回-1
s.Push(3)       // 堆栈增加元素3，当前堆栈[3]
s.Push(4)       // 堆栈增加元素4，当前堆栈[3,4]
s.Push(4)       // 堆栈增加元素4，当前堆栈[3,4,4]
s.Push(5)       // 堆栈增加元素5，当前堆栈[3,4,4,5]
s.Push(5)       // 堆栈增加元素5，当前堆栈[3,4,4,5,5]
s.PeekMedian() // 当前堆栈[3,4,4,5,5], (5+1)/2=3，中值是第3小的元素，故返回4
2、 同工作级第三题
3、 恰逢圣诞、元旦双节，终端产品策划一个拼团团购活动，请你给设计一个系统支持本次活动，规则如下：
拼团的团数不限，每个拼团的优惠商品配额相等、并固定为 eachSize。拼团从 0 开始编号，顺序递增。系统支持拼团申请功能。系统支持删除指定团（编号为 groupIndex ）的团尾一次拼团申请。系统支持剔除最后一个非空拼团的团尾一次拼团申请。系统设计接口如下：
GroupBuying (int eachSize) - 初始化拼团申购系统，并指定每个拼团的配额。
void Join(int id) - 接受某人（id）的一次拼团申请，加入规则如下：
优先分配到编号尽量小、有空余名额的团，若当前所有团满员，则新开一团。申请参团即占用团内一名额，并分配到团尾第一个空余位置。一次申请只能买一件商品，多买需多次申请。
int RemoveFrom(int groupIndex); 删除拼团编号为 groupIndex 的团尾的一次申请，并返回此成员的 id；如果编号 groupIndex 的拼团已空，则返回 -1。
int RemoveLast(void); 删除最后一个非空拼团的团尾的一次申请，并返回此成员 id；如果所有拼团都空了，则返回 -1。
注：上述描述中的接口仅作为参考，实际以你所选择的语言规范为准。1 <= eachSize <= 20000, 1 <= id <= 20000, 0 <= groupIndex <= 100000, 最多会对 Join，RemoveFrom，和 RemoveLast 进行 200000 次调用，请考虑系统性能问题。
例1：
输入：["GroupBuying","join","join","join","join","join","removeFrom","join","join","removeFrom","removeFrom","removeLast","removeLast","removeLast","removeLast","removeLast"]
[ [2], [1], [1], [1], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], [] ]
输出：[null, null, null, null, null, null, 1, null, null, 20, 21, 5, 4, 1, 1, -1]
解释：GroupBuying groups = GroupBuying(2);  // 初始化，一个拼团的商品数量上限 eachSize = 2
groups.Join(1);
groups.Join(1);
groups.Join(1);
groups.Join(4);
groups.Join(5);             // 拼团的现状为：
                              [0]  1  1
                                  [1]  1  4
                                  [2]  5
groups.RemoveFrom(0);   // 返回 1。拼团现状为：
                                  [0]  1
                                  [1]  1  4
                                  [2]  5
groups.Join(20);          // 拼团现状为：
                                  [0]  1  20
                                  [1]  1  4
                                  [2]  5
groups.Join(21);          // 拼团现状为：
                                  [0]  1  20
                                  [1]  1  4
                                  [2]  5  21
groups.RemoveFrom(0);   // 返回 20。拼团现状为：
                                  [0]  1
                                  [1]  1  4
                                  [2]  5  21
groups.RemoveFrom(2);   // 返回 21。拼团现状为：
                                  [0]  1
                                  [1]  1  4
                                  [2]  5
groups. RemoveLast()；   // 返回 5。拼团现状为：
                                  [0]  1
                                  [1]  1  4
groups. RemoveLast()；   // 返回 4。拼团现状为：
                                  [0]  1
                                  [1]  1
groups. RemoveLast()；   // 返回 1。拼团现状为：
                                  [0]  1  
groups. RemoveLast()；   // 返回 1。现在没有拼团。
groups. RemoveLast()；   // 返回 -1。仍然没有拼团。
函数 / 类的调用方式（以 C 语言为例，其他语言参考）：
/*
 * Your GroupBuying struct will be instantiated and called as such:
 * GroupBuying * groups = GroupsCreate ( eachSize );
 * GroupsJoin(groups, id);
 * int param_2 = GroupsRemoveLast(groups);
 * int param_3 = GroupsRemoveFrom(groups, groupIndex);
 * GroupsFree(groups);
*/

```
