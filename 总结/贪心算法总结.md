## 基本理论
### 贪心算法的一般思路
1. 将问题分为若干个子问题
2. 找出适合的贪心策略
3. 求解每一个子问题的最优解
4. 将局部最优解堆叠成全局最优解

## 练习题
### leetcode 455
#### 思路
1. 将每个孩子的胃口 和 饼干大小按照从小到大的顺序来排序，把饼干大小作为外循环，孩子胃口作为内循环，分别倒序遍历饼干大小和胃口大小，如果饼干大于等于胃口，则表示能够喂饱一个孩子。
2. 一旦找到一个满足胃口的孩子时，把返回结果加1，并且要终止孩子胃口的遍历。关键点是，当前这个孩子已经喂饱了，所以在跳出for循环时，要把循环变量减1.
#### 代码
```
int findContentChildren(int* g, int gSize, int* s, int sSize){
    qsort(g, gSize, sizeof(int), cmp);
    qsort(s, sSize, sizeof(int), cmp);
    int res = 0;
    int j = gSize - 1;
    for (int i = sSize - 1; i >= 0; i--) {
        for (; j >= 0; j--) {
            if (s[i] >= g[j]) {
                res++;
                j--;
                break;
            }
        }
    }
    return res;
}
```
一个简洁版本的代码,将2个for循环改成1个
```
int cmp(const void* a, const void* b)
{
    int* aa = (int*)a;
    int* bb = (int*)b;
    return aa[0] - bb[0];
} 

int findContentChildren(int* g, int gSize, int* s, int sSize){
    qsort(g, gSize, sizeof(int), cmp);
    qsort(s, sSize, sizeof(int), cmp);
    int res = 0;
    int idx = sSize - 1;
    for (int i = gSize - 1; i >= 0; i--) {
        if (idx >= 0 && s[idx] >= g[i]) {
            res++;
            idx--;
        }
    }
    return res;
}
```