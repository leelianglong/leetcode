## 最长上升子序列专题

参考资料：
https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/


### 题目 leetcode 646

思路：
1. 要根据所给数队的第2个数字，按照升序排序。因为题目已经告诉，数对中第一个数字比第二个数字小了，这样排序后，从整体上来看都是升序了。
2. 取第一个数对的第2个元素为end, 然后从第2个数对开始遍历，比较每个数队的第一个元素是否大于end,如果大于则数队增加1，并且更新end为当前遍历的数对的第2个元素。

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] - bb[1];
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    if (pairsSize <= 0) {
        return 0;
    }
    qsort(pairs, pairsSize, sizeof(pairs[0]), cmp);
    int maxLength = 1;
    int begin = pairs[0][0];
    int end = pairs[0][1];
    for (int i = 1; i < pairsSize; i++) {
        if (end < pairs[i][0]) {
            maxLength++;
            end = pairs[i][1];
        }
    }
    return maxLength;
}
```


