## 最长上升子序列专题

参考资料：
https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/

### 题目 leetcode 300 最长上升子序列
题目大意是给定一个序列，要求出最长的递增序列。

思路：
1. 本题采用动态规划方法，如果按照完全的单调栈，得不到完全正确的答案。
2. 动态规划首先定义DP数组，并确定含义，本题DP[i]  表示 以nums[i] 结尾的最长上升子序列.
3. 确定基本状态，对于每一个数值，单独以它结尾，则至少有1个，所以DP[i] 都是 1.
4. 对于一个序列【a1, a2,a3,a4,a5】 假设已经知道以前面4个数分别结尾的最长递增子序列长度是【b1,b2,b3,b4】 ,现在如何求以a5结尾的最长子序列长度？
   分析如下，既然要求递增子序列，所以要在前面4个中找到小于a5的数字，把a5 接在它们后面，就能够组成递增子序列。现在要求最长的递增子序列，所以a5应该要接到比a5小，并且递增子序列最长的元素后面，
   所以就应该
```
   for (int i = 0; i < xx; i++) {
        for (int j = 0; j < i; j++) { // 在i 前面找比 a[i] 小的a[j], 并且递增子序列要最长的
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1) // + 1 就是num[i]元素本身。 max是求最大。
   }
```
### 代码
```
int lengthOfLIS(int* nums, int numsSize){
    if (numsSize <= 0) {
        return 0;
    }
    int dp[numsSize];
    for (int i = 0; i < numsSize; i++) {
        dp[i] = 1;
    }

   for (int i = 0; i < numsSize; i++) {
       for (int j = 0; j < i; j++) {
           if (nums[i] > nums[j]) {
               dp[i] = dp[i] > (dp[j] + 1) ? dp[i] : (dp[j] + 1);
           }
       }
   } 
   int res = 0;
   for (int i = 0; i < numsSize; i++) {
       res = res > dp[i] ? res : dp[i];
   }
   return res;
}
```

### 题目 最长数对链 leetcode 646

思路：
1. 要根据所给数队的第2个数字，按照升序排序。因为题目已经告诉，数对中第一个数字比第二个数字小了，这样排序后，从整体上来看都是升序了。
2. 取第一个数对的第2个元素为end, 然后从第2个数对开始遍历，比较每个数队的第一个元素是否大于end,如果大于则数队增加1，并且更新end为当前遍历的数对的第2个元素。

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] - bb[1];
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    if (pairsSize <= 0) {
        return 0;
    }
    qsort(pairs, pairsSize, sizeof(pairs[0]), cmp);
    int maxLength = 1;
    int begin = pairs[0][0];
    int end = pairs[0][1];
    for (int i = 1; i < pairsSize; i++) {
        if (end < pairs[i][0]) {
            maxLength++;
            end = pairs[i][1];
        }
    }
    return maxLength;
}
```

思路2： 动态规划

1、我们定义dp[i] 表示以第i个数对结束时，最长的数对数。
2、假设我们已经知道第 i - 1 个数对结束时，最长的数对为max，如何求出第  i 个数对结束时的最长数对？ 从下面2个方面入手：
   我们需要在前面i-1个数对中找到一个合适的位置，使其第i个数对接在它后面能够变成递增，并选择其中一个能使其递增序列最长的。这两点的代码如下：
···
    int max = 0;
    for (int i = 0; i < pairsSize; i++) {
        for (int j = 0; j < i; j++) {
            if (pairs[j][1] < pairs[i][0] && dp[j] > max) {
                max = dp[j];
            }
        }
        dp[i] = max + 1;
        if (dp[i] >maxLength) {
            maxLength = dp[i];
        }
    }
···

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] - bb[1];
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    if (pairsSize <= 0) {
        return 0;
    }
    qsort(pairs, pairsSize, sizeof(pairs[0]), cmp);
    
    int dp[pairsSize];
    int maxLength = 0;
    for (int i = 0; i < pairsSize; i++) {
        dp[i] = 1;
    }
    int max = 0;
    for (int i = 0; i < pairsSize; i++) {
        for (int j = 0; j < i; j++) {
            if (pairs[j][1] < pairs[i][0] && dp[j] > max) {
                max = dp[j];
            }
        }
        dp[i] = max + 1;
        if (dp[i] >maxLength) {
            maxLength = dp[i];
        }
    }
    return maxLength;
}
```

### 题目 无重叠区间 leetcode 435
题目大意时，删除多少个区间能够使区间不重叠， 分析最终的答案，实际上所有的区间变成递增的了。根据之前递增子序列的方法可以计算出最长的递增子序列。对于本题，只要计算出最长的递增子序列长度后，使用
总的队列长度减去递增子序列即可。
根据动态规划，求递增子序列的方法见上面分析。

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[0] - bb[0];
}

int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize){
    if (intervalsSize <= 0) {
        return 0;
    }
    int res = 0;
    int max = 0;

    qsort(intervals, intervalsSize, sizeof(intervals[0]), cmp);
    int dp[intervalsSize];
    for (int i = 0; i < intervalsSize; i++) {
        dp[i] = 1;
    }
    for (int i = 0; i < intervalsSize; i++) {
        max = 0;
        for (int j = 0; j < i; j++) {  // 在i前面找到比当前i的首元素小的数对时，记录当前递增子序列的长度。最终取最大值
            if (intervals[i][0] >= intervals[j][1] && dp[j] > max) {
                max = dp[j];
            }
        }
        dp[i] = max + 1;
        if (dp[i] > res) {
            res = dp[i];
        }
    }

    return intervalsSize - res; // 要删除的个数就是从总的长度减去最长递增子序列。
}
```


