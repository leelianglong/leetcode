## 最长上升子序列专题

参考资料：
https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/

### 题目 leetcode 300 最长上升子序列
题目大意是给定一个序列，要求出最长的递增序列。

思路：
1. 本题采用动态规划方法，如果按照完全的单调栈，得不到完全正确的解法。
2. 动态规划首先定义DP数组，并确定含义，本题DP[i]  表示 以nums[i] 结尾的最长上升子序列.
3. 确定基本状态，对于每一个数值，单独以它结尾，则至少有1个，所以DP[i] 都是 1.
4. 对于一个序列【a1, a2,a3,a4,a5】 假设已经知道以前面4个数分别结尾的最长递增子序列长度是【b1,b2,b3,b4】 ,现在如何求以a5结尾的最长子序列长度？
   分析如下，既然要求递增子序列，所以要在前面4个中找到小于a5的数字，把a5 接在它们后面，就能够组成递增子序列。现在要求最长的递增子序列，所以a5应该要接到比a5小，并且递增子序列最长的元素后面，
   所以就应该
   for (int i = 0; i < xx; i++) {
        for (int j = 0; j < i; j++) // 在i 前面找比 a[i] 小的a[j], 并且递增子序列要最长的
        {
        if (nums[j] < nums[i]) {
        
        dp[i] = max(dp[i], dp[j] + 1) // + 1 就是num[i]元素本身。 max是求最大。
   }
### 代码
```
int lengthOfLIS(int* nums, int numsSize){
    if (numsSize <= 0) {
        return 0;
    }
    int dp[numsSize];
    for (int i = 0; i < numsSize; i++) {
        dp[i] = 1;
    }

   for (int i = 0; i < numsSize; i++) {
       for (int j = 0; j < i; j++) {
           if (nums[i] > nums[j]) {
               dp[i] = dp[i] > (dp[j] + 1) ? dp[i] : (dp[j] + 1);
           }
       }
   } 
   int res = 0;
   for (int i = 0; i < numsSize; i++) {
       res = res > dp[i] ? res : dp[i];
   }
   return res;
}
```

### 题目 leetcode 646

思路：
1. 要根据所给数队的第2个数字，按照升序排序。因为题目已经告诉，数对中第一个数字比第二个数字小了，这样排序后，从整体上来看都是升序了。
2. 取第一个数对的第2个元素为end, 然后从第2个数对开始遍历，比较每个数队的第一个元素是否大于end,如果大于则数队增加1，并且更新end为当前遍历的数对的第2个元素。

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] - bb[1];
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    if (pairsSize <= 0) {
        return 0;
    }
    qsort(pairs, pairsSize, sizeof(pairs[0]), cmp);
    int maxLength = 1;
    int begin = pairs[0][0];
    int end = pairs[0][1];
    for (int i = 1; i < pairsSize; i++) {
        if (end < pairs[i][0]) {
            maxLength++;
            end = pairs[i][1];
        }
    }
    return maxLength;
}
```


