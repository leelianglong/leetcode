## 最长上升子序列专题

参考资料：
https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/

### 题目 leetcode 300 最长上升子序列
题目大意是给定一个序列，要求出最长的递增序列。

思路：
1. 本题采用动态规划方法，如果按照完全的单调栈，得不到完全正确的答案。
2. 动态规划首先定义DP数组，并确定含义，本题DP[i]  表示 以nums[i] 结尾的最长上升子序列.
3. 确定基本状态，对于每一个数值，单独以它结尾，则至少有1个，所以DP[i] 都是 1.
4. 对于一个序列【a1, a2,a3,a4,a5】 假设已经知道以前面4个数分别结尾的最长递增子序列长度是【b1,b2,b3,b4】 ,现在如何求以a5结尾的最长子序列长度？
   分析如下，既然要求递增子序列，所以要在前面4个中找到小于a5的数字，把a5 接在它们后面，就能够组成递增子序列。现在要求最长的递增子序列，所以a5应该要接到比a5小，并且递增子序列最长的元素后面，
   所以就应该
```
   for (int i = 0; i < xx; i++) {
        for (int j = 0; j < i; j++) { // 在i 前面找比 a[i] 小的a[j], 并且递增子序列要最长的
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1) // + 1 就是num[i]元素本身。 max是求最大。
   }
```
### 代码
```
int lengthOfLIS(int* nums, int numsSize){
    if (numsSize <= 0) {
        return 0;
    }
    int dp[numsSize];
    for (int i = 0; i < numsSize; i++) {
        dp[i] = 1;
    }

   for (int i = 0; i < numsSize; i++) {
       for (int j = 0; j < i; j++) {
           if (nums[i] > nums[j]) {
               dp[i] = dp[i] > (dp[j] + 1) ? dp[i] : (dp[j] + 1);
           }
       }
   } 
   int res = 0;
   for (int i = 0; i < numsSize; i++) {
       res = res > dp[i] ? res : dp[i];
   }
   return res;
}
```

### 题目 最长数对链 leetcode 646

思路：
1. 要根据所给数队的第2个数字，按照升序排序。因为题目已经告诉，数对中第一个数字比第二个数字小了，这样排序后，从整体上来看都是升序了。
2. 取第一个数对的第2个元素为end, 然后从第2个数对开始遍历，比较每个数队的第一个元素是否大于end,如果大于则数队增加1，并且更新end为当前遍历的数对的第2个元素。

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] - bb[1];
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    if (pairsSize <= 0) {
        return 0;
    }
    qsort(pairs, pairsSize, sizeof(pairs[0]), cmp);
    int maxLength = 1;
    int begin = pairs[0][0];
    int end = pairs[0][1];
    for (int i = 1; i < pairsSize; i++) {
        if (end < pairs[i][0]) {
            maxLength++;
            end = pairs[i][1];
        }
    }
    return maxLength;
}
```

思路2： 动态规划

1、我们定义dp[i] 表示以第i个数对结束时，最长的数对数。

2、假设我们已经知道第 i - 1 个数对结束时，最长的数对为max，如何求出第  i 个数对结束时的最长数对？ 从下面2个方面入手：

   我们需要在前面i-1个数对中找到一个合适的位置，使其第i个数对接在它后面能够变成递增，并选择其中一个能使其递增序列最长的。这两点的代码如下：
···
    int max = 0;
    for (int i = 0; i < pairsSize; i++) {
        for (int j = 0; j < i; j++) {
            if (pairs[j][1] < pairs[i][0] && dp[j] > max) {
                max = dp[j];
            }
        }
        dp[i] = max + 1;
        if (dp[i] >maxLength) {
            maxLength = dp[i];
        }
    }
···

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] - bb[1];
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    if (pairsSize <= 0) {
        return 0;
    }
    qsort(pairs, pairsSize, sizeof(pairs[0]), cmp);
    
    int dp[pairsSize];
    int maxLength = 0;
    for (int i = 0; i < pairsSize; i++) {
        dp[i] = 1;
    }
    int max = 0;
    for (int i = 0; i < pairsSize; i++) {
        for (int j = 0; j < i; j++) {
            if (pairs[j][1] < pairs[i][0] && dp[j] > max) {
                max = dp[j];
            }
        }
        dp[i] = max + 1;
        if (dp[i] >maxLength) {
            maxLength = dp[i];
        }
    }
    return maxLength;
}
```

### 题目 无重叠区间 leetcode 435
题目大意时，删除多少个区间能够使区间不重叠， 分析最终的答案，实际上所有的区间变成递增（相等也可）的了。根据之前递增子序列的方法可以计算出最长的递增子序列。对于本题，只要计算出最长的递增子序列长度后，使用
总的队列长度减去递增子序列即可。
根据动态规划，求递增子序列的方法见上面分析。

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[0] - bb[0];
}

int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize){
    if (intervalsSize <= 0) {
        return 0;
    }
    int res = 0;
    int max = 0;

    qsort(intervals, intervalsSize, sizeof(intervals[0]), cmp);
    int dp[intervalsSize];
    for (int i = 0; i < intervalsSize; i++) {
        dp[i] = 1;
    }
    for (int i = 0; i < intervalsSize; i++) {
        max = 0;
        for (int j = 0; j < i; j++) {  // 在i前面找到比当前i的首元素小的数对时，记录当前递增子序列的长度。最终取最大值
            if (intervals[i][0] >= intervals[j][1] && dp[j] > max) {
                max = dp[j];
            }
        }
        dp[i] = max + 1;
        if (dp[i] > res) {
            res = dp[i];
        }
    }

    return intervalsSize - res; // 要删除的个数就是从总的长度减去最长递增子序列。
}
```

### 题目 leetcode 452
使用最少的箭射破气球
该题实际上就是求不重叠区间个数

### 代码
```
int cmp(const void* a, const void* b)
{
    int* aa = *(int**)a;
    int* bb = *(int**)b;
    return aa[1] < bb[1];
}

int findMinArrowShots(int** points, int pointsSize, int* pointsColSize){
    if (pointsSize <= 0) {
        return 0;
    }
    qsort(points, pointsSize, sizeof(points[0]), cmp);
    int dp[pointsSize];
    for (int i = 0; i < pointsSize; i++) {
        dp[i] = 1;
    }
    int res = 1;
    for (int i = 0; i < pointsSize; i++) {
        for (int j = 0; j < i; j++) {
            if (points[i][0] > points[j][1]) {
                dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;
            }
        }
        res = res > dp[i] ? res : dp[i];
    }
    return res;
}
```


### 题目 leetcode 673
最长递增子序列的个数

### 代码
```
int findNumberOfLIS(int* nums, int numsSize){
    if (numsSize <= 0) {
        return 0;
    }
    int dp[numsSize]; // 表示以num[i]结尾的最长递增子序列的长度
    int count[numsSize]; // 表示以nums[i]结尾的最长递增子序列的组合数
    for (int i = 0; i < numsSize; i++) {
        dp[i] = 1;
        count[i] = 1;
    }
    int res = 0;
    int max = 0;
    for (int i = 0; i < numsSize; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                if (dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    count[i] = count[j];
                } else if (dp[j] + 1 == dp[i]){
                    count[i] += count[j];
                }
            }
        }
        max = max > dp[i] ? max : dp[i];
    }
    for (int i = 0; i < numsSize; i++) {
        if (dp[i] == max) {
            res += count[i];
        }
    }
    return res;
}
```

### 题目 leetcode 5551
题目要求，使用最少的删除次数，使字符串平衡。字符串平衡的原则是 如果 i < j ,则 s[i] < s[j]

思路：

1. 定义dp[length +1][2] 的数组，其中 dp[x][0] 用来记录以a结尾，到当前x平衡时需要删除的次数， dp[x][1] 用来记录以b结尾，当前X平衡时需要删除的次数

### 代码
```

int minimumDeletions(char * s){
    int dp[strlen(s) + 1][2];
    for (int i = 0; i < strlen(s); i++) {
        for (int j = 0; j < 2; j++) {
            dp[i][j] = 0;
        }
    }

    for (int i = 1; i <= strlen(s); i++) {
        if (s[i - 1] == 'a') {
            dp[i][0] = dp[i - 1][0]; // 以a结尾，遇到a无需操作
            dp[i][1] = dp[i - 1][1] + 1;// 以a结尾，遇到b需要删除一次，即把
        } else {
            dp[i][0] = dp[i - 1][0] + 1;
            dp[i][1] = MIN(dp[i - 1][1], dp[i - 1][0]);// 以b结尾，遇到b时，需要计算以b结尾和以a结尾中较小的作为结果
        }
    }
    return MIN(dp[strlen(s)][0], dp[strlen(s)][1]);
}
```

另一种非动态规划的解法
```
int minimumDeletions(char * s){
    int pre[100001] = {0};
    for (int i = 0; i < strlen(s); i++) {
        pre[i + 1] = pre[i];
        if (s[i] == 'b') {
            pre[i + 1]++;
        }
    }
    int suf[100001] = {0};
    for (int j = strlen(s) - 1; j >= 0; j--) {
        suf[j] = suf[j + 1];
        if (s[j] == 'a') {
            suf[j]++;
        }
    }
    int res = 1e9;
    for (int i = 0; i <= strlen(s); i++) {
        res = res > (pre[i] + suf[i]) ? (pre[i] + suf[i]) : res;
    }
    return res;
}
```

### leetcode 70, 509
#### 思路
1. 对于动态规划，要确定dp数组的含义和初始化。确定如何在知道dp[n - 1] 的情况下推导出dp[n]；还有就是如何初始化；最后确定返回的是dp数组中的那个值。

#### 70题代码
```
int climbStairs(int n){
    int dp[n + 1];
    dp[0] = 1;
    dp[1] = 2;

    for (int i = 2; i < n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n - 1];
}
```

再看看不同初始化的情况
```
int climbStairs(int n){
    int dp[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

### leetcode 322
#### 思路
1. 定义dp数组 dp[i]表示凑够i元所需的最少硬币数量。
2. 当前题目要凑够amount元，所以dp数组的大小设置成amount + 1.这样可以把dp[0] 空出来不用，方便计算dp[i] 就是i元所需的硬币，而不是 i + 1元所需的硬币
3. 当前题目也就是01背包问题，外层循环使用包的容量来遍历，这里就是amount.内层循环是物品，也就是coins的循环遍历。根据01背包问题的递推公式,判断要还是不要的最优解即可。代码中的dp[i] = min(dp[i], dp[i - coins[k]] + 1)的含义见注释

#### 代码
```
#define MIN(a, b) ((a) > (b) ? (b) : (a))
int coinChange(int* coins, int coinsSize, int amount){
    int dp[amount + 1]; // dp[i] 标示凑够i元需要的最少硬币数目
    for (int i = 0; i < amount + 1; i++) {
        dp[i] = amount + 1;
    }
    dp[0] = 0; // 要凑0元不需要硬币
    
    for (int i = 0; i < amount + 1; i++) {
        for (int k = 0; k < coinsSize; k++) {
            if (i - coins[k] < 0) {
                continue;
            }
            dp[i] = MIN(dp[i], dp[i - coins[k]] + 1); // 对于要凑i元，当前面前有k种硬币，你是选择(dp[i - coin[k]] + 1)还是不选择（dp[i]），得到的硬币数少。
        }
    }
    return dp[amount] == amount + 1 ? -1 : dp[amount];
}
```
### leetcode 152
#### 思路
1. 当前总共有4种情况，dp[i - 1] 大于或小于0，以及 num[i]的大于或小于0的情况， 他们有时候直接相乘即可，有时候需要dp需要从nums[i]开始.
2. 令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])
由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])
当负数出现时则imax与imin进行交换再进行下一步计算.下面这种题解很明白
#### 代码
```
class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i<nums.length; i++){
            if(nums[i] < 0){ 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            }
            imax = Math.max(imax*nums[i], nums[i]); // 这里就表示是直接乘上去还是 从nums[i]开始
            imin = Math.min(imin*nums[i], nums[i]);
            
            max = Math.max(max, imax);
        }
        return max;
    }
}
```

### leetcode 740
#### 思路
详见代码注释。

#### 代码
```
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int deleteAndEarn(int* nums, int numsSize){
    if (numsSize <= 0) {
        return 0;
    }
    if (numsSize == 1) {
        return nums[0];
    }

    int value[10001] = {0};
    for (int i = 0; i < numsSize; i++) {
        value[nums[i]] += nums[i]; // value[i]表示数值i所具有的点数 
    }
    int dp[10001] = {0}; // dp[i]表示i具有最大点数
    dp[0] = 0;
    dp[1] = value[1];
    for (int i = 2; i < 10001; i++) {
        dp[i] = MAX(dp[i - 1], dp[i - 2] + value[i]); // 如果不删除当前元素，那么最大的点数就和前 i - 1的最大点数一样，如果删除了，则就是和前 i - 2的点数 + 当前值的点数， 取二者中最大者。
    }
    return dp[10000];
}
```

### leetcode 198
#### 思路
详见代码注释
#### 代码
```
#define MAX(a, b)  ((a) > (b) ? (a) : (b))

int rob(int* nums, int numsSize){
    if (numsSize <= 0) {
        return 0;
    }
    if (numsSize == 1) {
        return nums[0];
    }
    if (numsSize == 2) {
        return MAX(nums[0], nums[1]);
    }
    int dp[numsSize]; // dp[i] 表示以以nums[i]结尾的最大子序列和。
    memset(dp, 0, sizeof(dp));
    dp[0] = nums[0];
    dp[1] = MAX(nums[0], nums[1]);
    for (int i = 2; i < numsSize; i++) {
        dp[i] = MAX(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[numsSize - 1];
}
```