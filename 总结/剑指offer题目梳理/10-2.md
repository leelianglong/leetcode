### 青蛙跳台阶

用f(1)表示跳到第一个台阶的路径数
用f(2)表示跳到第二个台阶的路径数
用f(3)表示跳到第三个台阶的路径数
用f(4)表示跳到第四个台阶的路径数
用f(n)表示跳到第n个台阶的路径数

f(1)：直接一下跳上去。
f(1) = 1。

f(2)：想跳到第二个台阶，有两种办法：
方法一：从第一个台阶跳一步到达。有f(1)种路径
方法二：直接跳到第二个台阶。有一种路径。
共f(1) + 1 = 2种路径。

f(3)：想跳到第三个台阶，有两种办法：
方法一：从第一个台阶跳两步到达。有f(1)种路径。
方法二：从第二个台阶跳一步到达。有f(2)种路径。
共f(1) + f(2) = 3种路径。

f(4)：想跳到第四个台阶，有两种办法：
方法一：从第二个台阶跳两步到达。有f(2)种路径。
方法二：从第三个台阶跳一步到达。有f(3)种路径。
共f(2) + f(3) = 5种路径。

f(5)：想跳到第五个台阶，有两种办法：
方法一：从第三个台阶跳两步到达。有f(3)种路径。
方法二：从第四个台阶跳一步到达。有f(4)种路径。
共f(3) + f(4) = 8种路径。

f(n)：想跳到第n个台阶，有两种办法：
方法一：从第n-2个台阶跳两步到达。有f(n-2)种路径。
方法二：从第n-1个台阶跳一步到达。有f(n-1)种路径。
共f(n-2) + f(n-1)种路径。

### 代码
```
int memo[101] = {1,2};
int numWays(int n){
    int const MOD = 1e9 + 7;
    if (n == 0) {
        return 1;
    }
    if (n <= 2) {
        return n;
    }
    if (memo[n] > 2) { // 如果有已经计算过的值的话，就直接返回。避免重复计算
        return memo[n];
    }
    memo[n] = numWays(n - 1) % MOD + numWays(n - 2) % MOD;
    return memo[n] % MOD;
}
```
