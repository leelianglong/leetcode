#### sttcat(char* dst, char* src)

该函数把src指向的字符串链接到dst指向的字符串的后面，会覆盖dst字符串的结束符，最终会生成结束符

#### strcpy(char* dst, char* src)

拷贝字符串，把src指向的字符串拷贝到dst指向的空间。注意如果dst中有内容的话，会被覆盖

#### strcspn(char* dst, char* src)

该函数返回 src字符串中任意一个字符在dst中出现的最小位置。举例说明：
```
strcspn("qew1234","4")                                ======返回值是6
strcspn("qew1234", "4w")                              ======返回值是2
strcspn("qew1234", "4wq")                             ======返回值是0
```

#### strpsn(char* dst, char* src)

该函数返回dst的部分字符串的长度，该部分字符串包含了src中的部分字符。
```
strspn("123hj", "12345678")                          ===== 返回值是3
strspn("123hj", "12345678h")                         ===== 返回值是4
```

#### strtok(char* str, char* token)

该函数使用 token中的字符把 str 字符串进行分割。具体用法如下：
```
    char strScan[] = "- this , is. morning, class";
    char* pstr = strtok(strScan, "- ,.");
    while(pstr != NULL) {
        printf("\n%s\n", pstr);
        pstr = strtok(NULL, " ,.");
    }
```
输出如下：
```
this

is

morning

class
```


#### 获取最长的连续数字
```
char* TheLongestSubNumberString(char* data)
{
    int length = strlen(data);
    int i;
    int startPos = 0;
    int maxNumLength = 0;
    int numCounter = 0;

    for (i = 0; i < length; i++) {
        if (isdigit(data[i])) {
            startPos = i;
            while (isdigit(data[i])) {
                i++;
                numCounter++;
                maxNumLength = maxNumLength > numCounter ? maxNumLength : numCounter;
            }
        } else {
            numCounter = 0;
        }
    }
    printf("start pos=%d total=%d\r\n", startPos, length);
    char* res = (char*)malloc(sizeof(char) * (maxNumLength + 1));
    memset(res, 0, (maxNumLength + 1));
    strncpy(res, &data[startPos], maxNumLength);
    return res;
}
```
