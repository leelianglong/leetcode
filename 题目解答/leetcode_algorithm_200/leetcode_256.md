### 题目
```
假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。

例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本

输入: costs = [[17,2,17],[16,16,5],[14,3,19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
     最少花费: 2 + 5 + 3 = 10。

输入: costs = [[7,6,2]]
输出: 2
```

### 思路
```
1. 要求n间房刷完使用的成本最小，并且每一间房跟相邻的房间不能使用相同的颜色，即每一间房的颜色不能固定下来，也就是说成本不能固定下来，只有递推来确定。
2. 对于需要递推计算结果的可以考虑动态规划。
3. 相邻房间的颜色不一样，所以在第i间房，选择颜色0时，要考虑前面i - 1 房，选择颜色1 或者 颜色2中最小的成本； 同理选择颜色1时，要在前i- 1间房选择颜色0 或者 2.以此类推。这样就能够从第i-1
房的成本退出第i间房的成本。
```

### 代码
```
int minCost(int** cost, int costsSize, int* costsColSize){
    int dp[costsSize][3]; // dp[i][j], 刷第i间房使用颜色j 花的最少的前
    dp[0][0] = cost[0][0];
    dp[0][1] = cost[0][1];
    dp[0][2] = cost[0][2];
    for (int i = 1; i < costsSize; i++) {
        dp[i][0] = fmin(dp[i - 1][1], dp[i - 1][2]) + cost[i][0];
        dp[i][1] = fmin(dp[i - 1][0], dp[i - 1][2]) + cost[i][1];
        dp[i][2] = fmin(dp[i - 1][0], dp[i - 1][1]) + cost[i][2];
    }
    int res = fmin(dp[costsSize - 1][0], fmin(dp[costsSize - 1][1], dp[costsSize - 1][2]));
    return res;
}
```
